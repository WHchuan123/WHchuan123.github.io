[{"title":"hdu6355","date":"2019-03-30T14:01:24.422Z","path":"2019/03/30/hdu6355/","text":"题意 在一个nnn维有限超立方体中 题解","tags":[{"name":"题解","slug":"题解","permalink":"http://WHchuan123.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"http://WHchuan123.github.io/tags/数学/"}]},{"title":"hdu6360","date":"2019-03-30T02:44:38.528Z","path":"2019/03/30/hdu6360/","text":"题意 给你nnn种颜色，让你给一个rhombic hexecontahedron的每一个面染色，要求第iii种颜色使用不少于aia_iai​次，求有多少本质不同的rhombic hexecontahedron。定义本质不同为存在一种旋转方案使得旋转前和旋转后不一样。 答案对任意数mmm取模。 rhombic hexecontahedron是什么呢？ rh_virtual rh_real 题解 pólya练手题然而并不会。我真是个白学家。 这个rhombic hexecontahedron本质上是从正十二面体进行一些操作变过来的。 正十二面体长这样： rd 很容易想到rhombic hexecontahedron的每个面都可以和正十二面体的每个顶点与做一个映射。这不是双射，因为正十二面体的每个顶点被三个面共用，所以要把一个点拆成三个，才能建立双射。 但是实际上并不需要在十二面体上考虑，只是帮助我们思考旋转的问题。 考虑有多少种不同的旋转作用在这个对象集合上： 1.以两个相对面的中心连线为轴，可以旋转2π5\\frac {2\\pi}{5}52π​，4π5\\frac {4\\pi}{5}54π​，6π5\\frac {6\\pi}{5}56π​，8π5\\frac {8\\pi}{5}58π​； 2.以两个相对棱的中点连线为轴，可以旋转π\\piπ； 3.以两个相对顶点连线为轴，可以旋转2π3\\frac {2\\pi}{3}32π​，4π3\\frac {4\\pi}{3}34π​； 4.不旋转。 任何一种旋转都是这里的一个，所以我们可以确定，整个旋转群里的置换就这么多。 1.12/2∗4=2412 / 2 * 4 = 2412/2∗4=24； 2.30/2∗1=1530 / 2 * 1 = 1530/2∗1=15； 3.20/2∗2=2020 / 2 * 2 = 2020/2∗2=20； 4.111。 总共24+15+20+1=6024 + 15 + 20 + 1 = 6024+15+20+1=60个置换。 然后套用pólya。 考虑对于共轭的置换一起算，一共有4个共轭类，分别计算即可。 考虑然后计算一个共轭类的答案，以第一种置换为例。 由于这个共轭类内所有置换的所有轮换的长度都是一样的，len=5len = 5len=5，由于对象数量为606060（即rhombic hexecontahedron的菱形面数），所以共有121212个轮换。 考虑设计dp，fi,jf_{i, j}fi,j​表示用前iii种颜色，对前jjj个轮换染色的方案数。 转移方程即为： fi,j=∑k=lowerupperfi−1,j−k(jk)f_{i, j} = \\sum_{k = lower} ^ {upper} f_{i - 1, j - k} \\binom {j}{k} fi,j​=k=lower∑upper​fi−1,j−k​(kj​) 其中upper​upper​upper​就是轮换个数，lower​lower​lower​则是颜色i​i​i​至少用了ai​a_i​ai​​次需要的最少轮换数（在这个共轭类中）。这个可以O(1)​O(1)​O(1)​计算。 最后，这个共轭类的答案就是fn,12(轮换个数)∗24(共轭类大小)f_{n, 12(轮换个数)} * 24(共轭类大小)fn,12(轮换个数)​∗24(共轭类大小) 复杂度O(n603)O(n 60 ^ 3)O(n603)。 有一个要注意的地方，因为最后答案还要除掉群的大小，大小是60，可能没有逆元。所以我们一开始把模数设为m∗60m * 60m∗60，中间都对这个东西取模（还要要用慢速乘），最后再把606060除掉。可以用反证来证明这样做的正确性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 60, G = 4, len[G + 1] = &#123;0, 1, 2, 3, 5&#125;, siz[G + 1] = &#123;0, 1, 15, 20, 24&#125;;int n, m, L; ll mo, tmp, ans;ll a[N + 1], s[G + 1], C[N + 1][N + 1], f[N + 1][N + 1];inline int read () &#123; static int x; scanf(\"%d\", &amp;x); return x;&#125;inline ll slow_mul (ll a, ll b) &#123; a %= mo, b %= mo; ll ret = a * b - (ll)((long double)a * b / mo) * mo; if ((ret %= mo) &lt; 0) ret += mo; return ret;&#125;void prep () &#123; C[0][0] = 1; for (int i = 1; i &lt;= N; ++i) &#123; C[i][0] = C[i][i] = 1; for (int j = 1; j &lt; i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mo; &#125;&#125;int main () &#123; for (int _ = read(); _; --_) &#123; n = read(), m = read(), L = 60, ans = 0, mo = (ll)m * N, prep(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); if (m == 1) &#123;puts(\"0\"); continue;&#125; for (int c = 1, upp, low; c &lt;= G; ++c) &#123; upp = L / len[c]; memset(f, 0, sizeof f), f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; low = a[i] ? (a[i] - 1) / len[c] + 1 : 0; for (int j = low; j &lt;= upp; ++j) for (int k = low; k &lt;= j; ++k) f[i][j] = (f[i][j] + slow_mul(f[i - 1][j - k], C[j][k])) % mo; &#125; ans = (ans + slow_mul(f[n][upp], siz[c])) % mo; &#125; printf(\"%lld\\n\", ans / N); &#125; return 0;&#125;","tags":[{"name":"题解","slug":"题解","permalink":"http://WHchuan123.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"http://WHchuan123.github.io/tags/数学/"}]},{"title":"hdu6352","date":"2019-03-29T13:32:27.120Z","path":"2019/03/29/hdu6352/","text":"题意 给出若干组询问，每次询问一个nnn，求将xn−1x ^ n - 1xn−1分解为分圆多项式的乘积。 具体的，即 xn−1=∏d∣nΦd(x)x ^ n - 1 = \\prod_{d | n} \\Phi_d(x) xn−1=d∣n∏​Φd​(x) 其中分圆多项式的定义为 Φn(x)=∏1≤k≤n,(n,k)=1(x−wnk)(wn=cos⁡2πn+isin⁡2πn)\\Phi_n(x) = \\prod_{1 \\le k \\le n, (n, k) = 1} (x - w_n ^ k) \\quad (w_n = \\cos \\frac {2\\pi}{n} + i\\sin \\frac {2\\pi}{n}) Φn​(x)=1≤k≤n,(n,k)=1∏​(x−wnk​)(wn​=cosn2π​+isinn2π​) （换句话说，让你求出一些分圆多项式） 题解 设f(n)=xn−1f(n) = x ^ n - 1f(n)=xn−1，g(d)=Φd(x)g(d) = \\Phi_d(x)g(d)=Φd​(x)，已知 f(n)=∏d∣ng(d)f(n) = \\prod_{d | n}g(d) f(n)=d∣n∏​g(d) 通过莫比乌斯反演，可以得到 g(n)=∏d∣nf(d)μ(nd)=∏d∣nf(nd)μ(d)\\begin{aligned} g(n) &amp; = \\prod_{d | n} f(d) ^ {\\mu(\\frac {n}{d})} \\\\ &amp; = \\prod_{d | n} f(\\frac {n}{d}) ^ {\\mu(d)} \\\\ \\end{aligned} g(n)​=d∣n∏​f(d)μ(dn​)=d∣n∏​f(dn​)μ(d)​ 注意到我们只需要μ(d)\\mu(d)μ(d)不为000的ddd，且满足的ddd都无平方质因子。 注意到d≤n≤105&lt;2×3×5×7×11×13×17​d \\le n \\le 10 ^ 5 &lt; 2 \\times 3 \\times 5 \\times 7 \\times 11 \\times 13 \\times 17​d≤n≤105&lt;2×3×5×7×11×13×17​，我们只要用26​2 ^ 6​26​枚举每个有用的d​d​d​即可。那么因子d​d​d​对g(n)​g(n)​g(n)​的贡献项为(1−xnd)μ(d)​(1 - x ^ {\\frac {n}{d}}) ^ {\\mu(d)}​(1−xdn​)μ(d)​。 如果用多项式乘法把他们搞起来当然不行，复杂度爆炸。 我考虑这个多项式只有两项有值，可以通过一个巧妙的dp（递推）进行计算。 具体来说， 如果乘上的是(1−xk)1(1 - x ^ k) ^ 1(1−xk)1，可以直接用递推来更新系数（本质是01背包）； 如果乘上的是(1−xk)−1(1 - x ^ k) ^ {-1}(1−xk)−1，亦即(1+xk+x2k+...)(1 + x ^ k + x ^ {2k} + ...)(1+xk+x2k+...)，可以用类似无限背包的递推来累加系数。 由于Φd(x)\\Phi_d(x)Φd​(x)的次数是ϕ(d)\\phi(d)ϕ(d)，那么这个部分只需要用O(ϕ(d))​O(\\phi(d))​O(ϕ(d))​的复杂度计算即可。 则总复杂度为O(∑d∣n2ω(d)ϕ(d))=O(n26)O(\\sum_{d | n} 2 ^ \\omega(d) \\phi(d)) = O(n2 ^ 6)O(∑d∣n​2ω(d)ϕ(d))=O(n26)。 由于数据保证∑n≤5⋅106\\sum n \\le 5 \\cdot 10 ^ 6∑n≤5⋅106，所以总复杂度大概是O(5⋅106⋅26)O(5 \\cdot 10 ^ 6 \\cdot 2 ^ 6)O(5⋅106⋅26)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline int read () &#123; static int x; scanf(\"%d\", &amp;x); return x;&#125;const int N = 1e5 + 5;int n, m;int phi[N], pr[N][7];int id[N]; bool vis[N];vector &lt;int&gt; poly[N];void prework () &#123; phi[1] = 1; for (int i = 2; i &lt; N; ++i) &#123; if (!pr[i][0]) for (int j = i; j &lt; N; j += i) pr[j][++pr[j][0]] = i; phi[i] = i; for (int j = 1; j &lt;= pr[i][0]; ++j) phi[i] -= phi[i] / pr[i][j]; &#125;&#125;bool cmp (int u, int v) &#123; if (phi[u] != phi[v]) return phi[u] &lt; phi[v]; for (int i = phi[u]; ~i; --i) if (poly[u][i] != poly[v][i]) return poly[u][i] &lt; poly[v][i]; return 0;&#125;signed main () &#123; prework(); for (int _ = read(); _; --_) &#123; n = read(), m = 0; for (int i = 1; i &lt;= n; ++i) if (n % i == 0) &#123; id[++m] = i; if (vis[i]) continue; poly[i].resize(phi[i] + 1, 0); poly[i][0] = i &gt; 1 ? 1 : -1; for (int j = 0; j &lt; (1 &lt;&lt; pr[i][0]); ++j) &#123; int d = i, s = 1; for (int k = 0; k &lt; pr[i][0]; ++k) if (j &gt;&gt; k &amp; 1) d /= pr[i][k + 1], s = -s; if (s &gt; 0) for (int j = phi[i]; j &gt;= d; --j) poly[i][j] -= poly[i][j - d]; else for (int j = d; j &lt;= phi[i]; ++j) poly[i][j] += poly[i][j - d]; &#125; vis[i] = 1; &#125; sort(id + 1, id + 1 + m, cmp); for (int i = 1, x; i &lt;= m; ++i) &#123; x = id[i]; putchar('('); for (int j = phi[x], f = 1; ~j; --j, f = 0) if (poly[x][j]) &#123; if (poly[x][j] &lt; 0) putchar('-'); else if (!f) putchar('+'); if (!j || abs(poly[x][j]) != 1) printf(\"%d\", abs(poly[x][j])); if (j) printf(\"x\"); if (j &gt; 1) printf(\"^%d\", j); &#125; putchar(')'); &#125; putchar('\\n'); &#125; return 0;&#125; （输出复杂度可能是个瓶颈，本地测是输不出来的，但提交后跑得很快，AC）。","tags":[{"name":"题解","slug":"题解","permalink":"http://WHchuan123.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"http://WHchuan123.github.io/tags/数学/"}]},{"title":"cf1136E","date":"2019-03-29T10:45:11.883Z","path":"2019/03/29/cf1136E/","text":"题意 给两个数组分别为aaa和kkk，有若干次操作： 1.给axa_xax​加上yyy，并以此对ax+i(i≥1)a_{x + i}(i \\ge 1)ax+i​(i≥1)赋值为max⁡{ax+i,ax+i−1+kx+i−1}\\max \\{a_{x + i}, a_{x + i - 1} + k_{x + i - 1}\\}max{ax+i​,ax+i−1​+kx+i−1​}。 2.询问区间[l,r][l, r][l,r]的aia_iai​的和。 题解 自闭了啊。 考虑把原序列分成若干个块，对于每个块内必须满足，除最后一个位置的所有位置iii，ai+ki=ai+1a_i + k_i = a_i + 1ai​+ki​=ai​+1。刚开始可以看成有nnn个块。 每次修改的时候，直接对每个块内用线段树修改，块与块之间可能有合并（最多合并O(n+q)O(n + q)O(n+q)次），然后每一次修改可能会产生O(1)O(1)O(1)个新的块。所有块用一个set维护一下。所以总复杂度是O((n+q)log⁡n)O((n + q) \\log n)O((n+q)logn)的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define fi first#define se second#define mp make_pairusing namespace std;typedef long long ll;typedef pair &lt;int, int&gt; pii; inline int read () &#123; static int x; scanf(\"%d\", &amp;x); return x;&#125;const int N = 1e5 + 5, inf = 2e9;int n, q, a[N], k[N]; ll pres[N];set &lt;pii&gt; block;ll s[N &lt;&lt; 2], tag[N &lt;&lt; 2];#define mid ((l + r) &gt;&gt; 1)#define lc (o &lt;&lt; 1)#define rc (o &lt;&lt; 1 | 1)#define ls lc, l, mid#define rs rc, mid + 1, rinline void pushdown (int o, int l, int r) &#123; s[lc] += tag[o] * (mid - l + 1), tag[lc] += tag[o]; s[rc] += tag[o] * (r - mid), tag[rc] += tag[o]; tag[o] = 0;&#125;inline void build (int o, int l, int r) &#123; if (l == r) &#123;s[o] = a[l]; return;&#125; build(ls), build(rs); s[o] = s[lc] + s[rc];&#125;inline void modify (int o, int l, int r, int x, int y, ll v) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123;s[o] += v * (r - l + 1), tag[o] += v; return;&#125; if (tag[o]) pushdown(o, l, r); if (x &lt;= mid) modify(ls, x, y, v); if (y &gt; mid) modify(rs, x, y, v); s[o] = s[lc] + s[rc];&#125;inline ll query (int o, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) return s[o]; if (tag[o]) pushdown(o, l, r); ll ret = 0; if (x &lt;= mid) ret += query(ls, x, y); if (y &gt; mid) ret += query(rs, x, y); return ret;&#125;void alter (int x, int v) &#123; set &lt;pii&gt; :: iterator b; int l, r; b = block.lower_bound(mp(x, inf)), --b; l = b-&gt;fi, r = b-&gt;se; block.erase(b); if (l &lt; x) block.insert(mp(l, x - 1)); modify(1, 1, n, x, r, v); for ( ; r &lt; n; ) &#123; ll s = query(1, 1, n, r, r), t = query(1, 1, n, r + 1, r + 1), delta = s + k[r] - t; if (delta &lt; 0) break; b = block.lower_bound(mp(r + 1, r + 1)); l = b-&gt;fi, r = b-&gt;se; block.erase(b); modify(1, 1, n, l, r, delta); &#125; block.insert(mp(x, r));&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(), pres[i] = pres[i - 1] + a[i]; for (int i = 1; i &lt; n; ++i) k[i] = read(); for (int i = 1; i &lt;= n; ++i) block.insert(mp(i, i)); build(1, 1, n); char op[5]; int x, y; for (int _ = read(); _; --_) &#123; scanf(\"%s\", op), x = read(), y = read(); if (op[0] == '+') alter(x, y); else printf(\"%lld\\n\", query(1, 1, n, x, y)); &#125; return 0;&#125;","tags":[{"name":"题解","slug":"题解","permalink":"http://WHchuan123.github.io/tags/题解/"},{"name":"数据结构","slug":"数据结构","permalink":"http://WHchuan123.github.io/tags/数据结构/"}]},{"title":"cf1139F","date":"2019-03-29T05:37:01.190Z","path":"2019/03/29/cf1139F/","text":"题意 给mmm个二维点，和nnn个等腰直角三角形，求对于每个点，被多少个三角形包含（边界也算）。 三角形给出形式：直角顶点(p,b)(p, b)(p,b)，斜边在x=sx = sx=s上。 题解 刚开始以为是整体二分之类的，然后被zlhD了一下后发现不用。 我们考虑把一个三角形的贡献拆成若干个不封闭区域的贡献。 具体来说，就是容斥之后，只要对于每个点求一些形如 1.y+y0=x+x0y + y_0 = x + x_0y+y0​=x+x0​与y+y0=−x+x0y + y_0 = -x + x_0y+y0​=−x+x0​围成的直角不封闭区域； 2.x=x0x = x_0x=x0​与y+y0=−x+x0y + y_0 = -x + x_0y+y0​=−x+x0​围成的135°角不封闭区域； 的区域的贡献和即可（容斥的过程中会有开闭区间的问题，不过不难处理）。 不妨只考虑第一种区域（第二种类似）。 我们考虑可以把每一个点变成从这个点射出去的斜率为1和-1的两条射线。 然后考虑一个点被一个区域包含当且仅当这个点射出的射线所形成的新区域。考虑在无穷远处有一堵墙，那么所照到的区间（即区域在x=∞x = \\inftyx=∞处的最下端和最上端形成的区间）一定是包含关系。 那么就变成了对于每个点，求其对应的区间被几个区域对应的区间包含即可。这个可以直接排序后树状数组。 复杂度O(nlog⁡n)O(n \\log n)O(nlogn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair &lt;int, int&gt; pi;typedef long long ll;inline int read () &#123; static int x; scanf(\"%d\", &amp;x); return x;&#125;const int N = 1e5 + 5;int n, m;int p[N], s[N], b[N];int ans[N];struct P &#123;int x, y, i;&#125; a[N];bool Pcmp_x (const P &amp;u, const P &amp;v) &#123;return u.x &lt; v.x;&#125;bool Pcmp_y (const P &amp;u, const P &amp;v) &#123;return u.y &lt; v.y;&#125;struct bitr &#123; int n, c[N &lt;&lt; 3]; void init (int _n) &#123; n = _n; memset(c, 0, sizeof c); &#125; void add (int x, int v) &#123; assert(abs(v) &lt;= 1); assert(x &lt;= n &amp;&amp; x &gt;= 1); for ( ; x &lt;= n; x += x &amp; (-x)) c[x] += v; &#125; int sum (int x, int ret = 0) &#123; assert(x &lt;= n &amp;&amp; x &gt;= 1); for ( ; x; x -= x &amp; (-x)) ret += c[x]; return ret; &#125;&#125;;struct interv &#123; int l, r, v; bool operator &lt; (const interv &amp;o) const &#123; return r == o.r ? v &lt; o.v : r &gt; o.r; &#125;&#125;;struct triangle &#123;int x, y, v;&#125;;bool Tcmp_x (const triangle &amp;u, const triangle &amp;v) &#123;return u.x &lt; v.x;&#125;bool Tcmp_y (const triangle &amp;u, const triangle &amp;v) &#123;return u.y &lt; v.y;&#125;int nt; triangle tri[N &lt;&lt; 1];int nf; interv f[N &lt;&lt; 2];int nv, val[N &lt;&lt; 3];bitr t;namespace Triangles &#123; void discrete () &#123; nv = 0; for (int i = 1; i &lt;= nf; ++i) val[++nv] = f[i].l, val[++nv] = f[i].r; sort(val + 1, val + 1 + nv), nv = unique(val + 1, val + 1 + nv) - val - 1; for (int i = 1; i &lt;= nf; ++i) &#123; f[i].l = lower_bound(val + 1, val + 1 + nv, f[i].l) - val; f[i].r = lower_bound(val + 1, val + 1 + nv, f[i].r) - val; &#125; sort(f + 1, f + 1 + nf); &#125; void main_solve () &#123; sort(a + 1, a + m + 1, Pcmp_x); nt = 0; for (int i = 1; i &lt;= n; ++i) &#123; tri[++nt] = (triangle) &#123;p[i], b[i], 0&#125;; tri[++nt] = (triangle) &#123;s[i] + 1, b[i] + s[i] - p[i] + 1, -1&#125;; &#125; sort(tri + 1, tri + nt + 1, Tcmp_x); int limit = max(a[m].x, tri[nt].x); nf = 0; for (int i = 1; i &lt;= nt; ++i) f[++nf] = (interv) &#123;tri[i].y - (limit - tri[i].x), tri[i].y + (limit - tri[i].x), tri[i].v&#125;; for (int i = 1; i &lt;= m; ++i) f[++nf] = (interv) &#123;a[i].y - (limit - a[i].x), a[i].y + (limit - a[i].x), a[i].i&#125;; discrete(); t.init(nv); for (int i = 1; i &lt;= nf; ++i) &#123; if (f[i].v &lt; 1) &#123; if (f[i].v == 0) f[i].v = 1; t.add(f[i].l, f[i].v); &#125; else ans[f[i].v] += t.sum(f[i].l); &#125; &#125;&#125;namespace Htriangles &#123; void discrete () &#123; nv = 0; for (int i = 1; i &lt;= nf; ++i) val[++nv] = f[i].l, val[++nv] = f[i].r; sort(val + 1, val + 1 + nv), nv = unique(val + 1, val + 1 + nv) - val - 1; for (int i = 1; i &lt;= nf; ++i) &#123; f[i].l = lower_bound(val + 1, val + 1 + nv, f[i].l) - val; f[i].r = lower_bound(val + 1, val + 1 + nv, f[i].r) - val; &#125; sort(f + 1, f + 1 + nf); &#125; void main_solve () &#123; sort(a + 1, a + m + 1, Pcmp_x); nt = 0; for (int i = 1; i &lt;= n; ++i) &#123; tri[++nt] = (triangle) &#123;s[i] + 1, b[i] - s[i] - 1 + p[i], 0&#125;; tri[++nt] = (triangle) &#123;s[i] + 1, b[i] + s[i] + 1 - p[i], -1&#125;; &#125; sort(tri + 1, tri + nt + 1, Tcmp_x); int limit = max(a[m].x, tri[nt].x); nf = 0; for (int i = 1; i &lt;= nt; ++i) f[++nf] = (interv) &#123;tri[i].y - (limit - tri[i].x), -tri[i].x, tri[i].v&#125;; for (int i = 1; i &lt;= m; ++i) f[++nf] = (interv) &#123;a[i].y - (limit - a[i].x), -a[i].x, a[i].i&#125;; discrete(); t.init(nv); for (int i = 1; i &lt;= nf; ++i) &#123; if (f[i].v &lt; 1) &#123; if (f[i].v == 0) f[i].v = 1; t.add(f[i].l, f[i].v); &#125; else ans[f[i].v] -= t.sum(f[i].l); &#125; &#125;&#125;signed main () &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) p[i] = read(); for (int i = 1; i &lt;= n; ++i) s[i] = read(); for (int i = 1; i &lt;= n; ++i) b[i] = read(); for (int i = 1; i &lt;= m; ++i) a[i].x = read(); for (int i = 1; i &lt;= m; ++i) a[i].y = read(); for (int i = 1; i &lt;= m; ++i) a[i].i = i; Triangles :: main_solve(); Htriangles :: main_solve(); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0;&#125;","tags":[{"name":"题解","slug":"题解","permalink":"http://WHchuan123.github.io/tags/题解/"},{"name":"数据结构","slug":"数据结构","permalink":"http://WHchuan123.github.io/tags/数据结构/"}]},{"title":"cf1140G","date":"2019-03-28T12:13:22.209Z","path":"2019/03/28/cf1140G/","text":"题意 给两棵同构的树，将同构节点之间连边，构成一张图。所有边有边权。给出一些询问，求某两点间的最短路。 题解 设两棵树分别为T,T′T, T&#x27;T,T′，同构节点们为x,x′x, x&#x27;x,x′。 注意到每个询问的答案一定是从uuu在某一棵树上走，然后走到另一棵树的同构节点，再在另外一棵树上走，这样的过程重复个若干次。 在一棵树上走一定是走简单路径；走到同构节点并非就是走那条直接相连的边，而是最短路。 先考虑最短路这么求？我们要求nnn对同构节点的最短路。 可以等价转化： 1.∀e(x,x′,wx)adde(0,x,wx)\\forall_{e(x, x&#x27;, w_x)}adde(0, x, w_x)∀e(x,x′,wx​)​adde(0,x,wx​) 2.∀e(x,y,w1,w2)adde(x,y,w1+w2)\\forall_{e(x, y, w_1, w_2)} adde(x, y, w_1 + w_2)∀e(x,y,w1​,w2​)​adde(x,y,w1​+w2​) 然后会发现这是对的……很神奇，就可以直接一遍sssp就好啦。 然后可以直接把最短路当做边权了。 那如何处理一整个问题？ 记录dpx,y,u,vdp_{x, y, u, v}dpx,y,u,v​代表从树uuu的节点xxx向上跳2y2 ^ y2y步且最终到达第v棵树上的最短路。其中u,vu, vu,v取值都是{0,1}\\{0, 1\\}{0,1}。发现可以把dpx,ydp_{x, y}dpx,y​看成一个2∗22 * 22∗2的矩阵。 为了方便，还要记录pdpdpd数组代表的是从上向下的最短路矩阵。 最后询问的时候倍增跳一跳，矩阵重定义运算一下，然后按顺序合并即可，注意合并的顺序。 复杂度O((n+Q)log⁡n)O((n + Q) \\log n)O((n+Q)logn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;typedef long long ll;inline int read () &#123; static int x; scanf(\"%lld\", &amp;x); return x;&#125;inline int readl () &#123; static ll x; scanf(\"%lld\", &amp;x); return x;&#125;const int N = 3e5 + 10, M = 2e6 + 10, H = 19;int n; ll D[N];struct Graph &#123; int n, tot; int lnk[N], nxt[M], son[M]; ll w[M]; void init (int _n) &#123; n = _n, tot = 1; memset(lnk, 0, sizeof lnk); &#125; void add (int x, int y, ll z) &#123; nxt[++tot] = lnk[x], lnk[x] = tot, son[tot] = y, w[tot] = z; &#125; void adde (int x, int y, ll z) &#123; add(x, y, z), add(y, x, z); &#125; void sssp () &#123; static ll dis[N]; static bool vis[N]; static queue &lt;int&gt; q; memset(dis, 60, sizeof dis), dis[0] = 0; memset(vis, 0, sizeof vis), vis[0] = 1; for ( ; !q.empty(); q.pop()); q.push(0); for ( ; !q.empty(); q.pop()) &#123; int x = q.front(); vis[x] = 0; for (int j = lnk[x]; j; j = nxt[j]) if (dis[son[j]] &gt; dis[x] + w[j]) &#123; dis[son[j]] = dis[x] + w[j]; if (!vis[son[j]]) vis[son[j]] = 1, q.push(son[j]); &#125; &#125; for (int i = 1; i &lt;= n; ++i) D[i] = dis[i]; &#125;&#125; G;struct Matrix &#123; ll a[2][2]; Matrix operator * (const Matrix &amp;o) &#123; return &#123;min(a[0][0] + o.a[0][0], a[0][1] + o.a[1][0]), min(a[0][0] + o.a[0][1], a[0][1] + o.a[1][1]), min(a[1][0] + o.a[0][0], a[1][1] + o.a[1][0]), min(a[1][0] + o.a[0][1], a[1][1] + o.a[1][1])&#125;; &#125;&#125;;struct Tree &#123; int n, tot; int lnk[N], nxt[N &lt;&lt; 1], son[N &lt;&lt; 1]; ll w1[N &lt;&lt; 1], w2[N &lt;&lt; 1]; int dep[N], fa[N][H + 1]; Matrix dp[N][H + 1], pd[N][H + 1]; void init (int _n) &#123; n = _n, tot = 1, dep[0] = 0; memset(lnk, 0, sizeof lnk); &#125; void add (int x, int y, ll z1, ll z2) &#123; nxt[++tot] = lnk[x], lnk[x] = tot, son[tot] = y, w1[tot] = z1, w2[tot] = z2; &#125; void adde (int x, int y, ll z1, ll z2) &#123; add(x, y, z1, z2), add(y, x, z1, z2); &#125; void dfs (int x, int p) &#123; fa[x][0] = p, dep[x] = dep[p] + 1; for (int j = lnk[x]; j; j = nxt[j]) if (son[j] != p) &#123; dfs(son[j], x); dp[son[j]][0] = &#123;w1[j], min(w1[j] + D[x], D[son[j]] + w2[j]), min(w1[j] + D[son[j]], D[x] + w2[j]), w2[j]&#125;; pd[son[j]][0] = &#123;w1[j], min(w1[j] + D[son[j]], D[x] + w2[j]), min(w1[j] + D[x], D[son[j]] + w2[j]), w2[j]&#125;; &#125; &#125; void build () &#123; for (int j = 1; j &lt;= H; ++j) for (int i = 1; i &lt;= n; ++i) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; dp[i][j] = dp[i][j - 1] * dp[fa[i][j - 1]][j - 1]; pd[i][j] = pd[fa[i][j - 1]][j - 1] * pd[i][j - 1]; &#125; &#125; int lca (int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); int dif = dep[x] - dep[y]; for (int j = H; ~j; --j) if (dif &gt;&gt; j &amp; 1) x = fa[x][j]; if (x == y) return x; for (int j = H; ~j; --j) if (fa[x][j] != fa[y][j]) x = fa[x][j], y = fa[y][j]; return fa[x][0]; &#125; ll query (int x, int y, int u, int v) &#123; static Matrix ans1, ans2, ans; ans1 = &#123;0, D[x], D[x], 0&#125;, ans2 = &#123;0, D[y], D[y], 0&#125;; int z = lca(x, y), dif; dif = dep[x] - dep[z]; for (int j = H; ~j; --j) if (dif &gt;&gt; j &amp; 1) ans1 = ans1 * dp[x][j], x = fa[x][j]; dif = dep[y] - dep[z]; for (int j = H; ~j; --j) if (dif &gt;&gt; j &amp; 1) ans2 = pd[y][j] * ans2, y = fa[y][j]; ans = ans1 * ans2; return ans.a[u][v]; &#125;&#125; T;signed main () &#123; n = read(), G.init(n), T.init(n); for (int i = 1; i &lt;= n; ++i) G.adde(0, i, readl()); for (int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); ll z1 = readl(), z2 = readl(); G.adde(x, y, z1 + z2), T.adde(x, y, z1, z2); &#125; G.sssp(); T.dfs(1, 0); T.build(); for (int _ = read(), x, y; _; --_) &#123; x = read() + 1, y = read() + 1; printf(\"%lld\\n\", T.query(x &gt;&gt; 1, y &gt;&gt; 1, x &amp; 1, y &amp; 1)); &#125; return 0;&#125; 不知为何全搞成long long才过。","tags":[{"name":"题解","slug":"题解","permalink":"http://WHchuan123.github.io/tags/题解/"},{"name":"数据结构","slug":"数据结构","permalink":"http://WHchuan123.github.io/tags/数据结构/"}]},{"title":"zjoi2019R1游记","date":"2019-03-25T11:17:50.805Z","path":"2019/03/25/zjoi2019R1游记/","text":"zjoi2019R1正在进行中…… 这大概是一篇回忆录啦。 回忆开始： Day -2 大概早早地就做着大巴车离开了xj……坐车的时候还是很激动的——又可以去玩了。但是事实上，大巴上极为无聊，还充斥着开车的叫声，坐着也很难受。 苟了2.5h后，终于到了镇海。 我们是先去的酒店。酒店一副中规中矩的样子，也并不差。 然后去参加了noip2018的颁奖典礼。没我啥事。 唯一的发现就是见到了fy本人。（演讲的气场好大） 晚上去填海食堂吃饭，发现xj包场二楼了。 晚上会宾馆颓颓颓，就不说了。 Day -1 今天有讲课很滋磁啊。到底讲什么呢？隐约感觉要讲杂题（那就给给了） 开始之后才发现是《具体数学》选讲，一看就来劲了。 然后发现下面一行字：镇海中学 罗煜翔 表示以前并未见过本人，只知道是个神仙。 真正讲课时发现和《具体数学》的关联不是特别大。主要的还是lyx本人的一些想法和套路的总结。感觉还可以吧，经过有一些听不懂的，但是还是见识到了神仙和他的一些想法。（课件里还有几道数学国集题，还是很滋磁的）上午也就这样。 下午很困。kcz将杂题。第一题看看不会然后就睡过去了。睡醒之后看了几道题，感觉没啥意思，然后就和小马哥下象棋了。（无限悔棋是谁想出来的？！） 晚上和毛哥一起回宾馆，途中感觉风特别冷（诡异？）。毛哥还觉得这个地方远不及江山城区那样热闹。在我看来那是必然。途中觉得xj其实很好，挺适合自己的，镇海这样的校园，反而有点让我这样的人无所适从。 Day 0 上午依然听讲课。范老师讲ds。 感觉xj的学长一个个都好牛逼啊，一个个上去秒题。 而我在下面自闭。太hard了。 听到AAA-tree就掉线了，尽管后面又重连了。 这远不如math来得清真，感觉自己这次省选的备考策略是很合理的。就紧紧抱着数学一条腿。（然而事实上我什么都没有复习） 中午吃饭的时候发现大家都自闭了，然后下午就组队会宾馆了。又是复习开车的好时光。颓了一下午。 晚上前半段继续打fifa。感觉自己的战术已经基本上成型了，面对top6不败。然而打利记的时候闪退了。自然是有不爽的，但是想想也就算了。毕竟是利记的球迷。看看表，时间不早了，就滚回去把隔膜都卸了。 尽管到现在还没复习任何东西，但是我其实心里不是很慌。 感觉明天的一切都是命运所决定的。做好准备，迎接挑战就行。 毕竟这代表着一个阶段学习的检验，无论结果如何，都应该认真对待。毕竟我们要活在未来才能活得更好。 Day 1 早上6点的闹钟，醒来后又睡过去了，一直到7点才起来。比较迷糊。 7点50进考场。发现到8点10分才有密码，但自己并没有感觉什么不爽的（场外选手，没有压力啊）。 开题。 看到T1就笑了。就知道这只九条可怜又要出麻将。 大致花了2个小时把3道题大概想了想，感觉T1能拿分。码码码。 然后调了1个小时。心态居然没崩。大概只能过n = 11的数据。 在途中调不出来，先把T2的暴力写了。 最后45分钟，在考虑是先打T3的暴力还是打T1的特殊性质。 一开始觉得特殊性质不好做，然后就去写T3了。然后考试结束也没调出来。 出来之后发现原来难度顺序是T2 &lt; T3 &lt; T1。发现很多人都秒了T2。 然后细思一下发现T2傻逼了。怎么说呢？就是没有反应过来~开车开过了~。而且在出考场时也似乎想到了T1的特殊性质大致做法。 然后就自闭了。但是感觉自己不是很难受。 总之之后想了很多，关于之后的路怎么走。剩下这些就记在后记里吧。 后记","tags":[]},{"title":"随感","date":"2019-03-21T02:00:47.298Z","path":"2019/03/21/随感/","text":"最近心里颇不宁静 让我把心里想说的慢慢到来。 省选将近。 前几天想整理一下所学算法和模板，但是又有很多东西还不会，所以斟酌了好久，到底应该先做什么。 在询问了X大爷和M大爷之后，心中才有了确切的答案。再加上自己整理东西的心思真的很重，就开始了整理工作。 但是整理到后面发现排版很不舒服，而且放在博客上也不好看，便想到了做成ppt。ppt的形式是很美观的。然后就想到了“痴迷已久”的LaTeX\\LaTeXLATE​X。 鉴于之前听Ch大爷说过，LaTeX\\LaTeXLATE​X这东西贼难装。事实上也是这样。装了整整半天，大概吧（包括找模板之类的）。 装好后兴奋至极。以为一切都能顺利进行了。但是事实远超我的预料。我整理东西的速度太慢了：尽管说对语法掌握的还挺快的，但是效率就是低下。 今天上午，整理着，突然就不想整理了。然后就停下了手头的工作，也就有了这一篇文章。 至于为什么会不想整理，是因为我大概明白了，我整理的最初想法消失了：我把大量时间耗费在排版上。那有什么意思呢？ 然而思绪并未就此停止。 我又想起了之前那段时间，疯狂刷题，疯狂看课件，疯狂积累套路，疯狂写博客。事实就是那段时间的确成效很大，学了很多。但是回过来想，发现还是有很多自己忘了的，但又不会回去翻看。那有什么用呢？ 直到今天，我才意识到，博客与我，并不是一个写题解，讲套路的地方。像这样，仅仅是倾诉自己的想法，为自己提供所需，不挺好的吗？我认为博客中写题解或是记录学习笔记，对我自己而言，用处其实很小。更应该做的，应该是写一些好的idea，一些属于自己的东西。如果所有人的博客都是学习笔记或题解，都是烂大街的东西（当然人人都有自己的想法和看法，这不否定），写多了也没什么。不如取其精华，记录些好的想法吧。 我知道，我没有那些神仙所拥有的能力，但是只要我的思想是自由的，我就不差于他们。而如果只是一味的学习，我觉得也没多大意思。 毕竟学OI的目的，不在于能不能上清北。如果真是这样，那就完了。竞赛里的乐趣，绝不是从这种目标得来的。不如把一切都看清，看轻，幸福就会来临。是真的幸福而不是单纯的幸福感。 所以说，至少是现在，在我看来，打隔膜也没有整理这种无聊的东西颓到那里去。毕竟打隔膜是真的自己想做的事情，而整理知识资料这种事情，我想应该是强迫症在作祟吧。 wuyiqi爷说的一些话还是挺对的： 去做你发自内心想做的事情，别再犹豫。","tags":[]},{"title":"共勉","date":"2019-03-17T00:40:55.619Z","path":"2019/03/17/共勉/","text":"曾经在某吧里面看到了一个远古帖子，许多湖北省的oier在对省队选拔中出现的偏差非常不满。不管孰错孰对，vfk在那里说的一段话令我惊叹。惊叹后是沉思。 节选如下： 我认为信息学竞赛考察的是信息学的思想，为了考察思想就得用一些手段。举一个简单的例子：XXXXXXXXXXXXXXXXXX，求最小值。假设这题方法是dp。这是纯信息题，认同吧。但是这样有缺点：既然是最小值嘛，有人可以绕开dp，用随机化之类的东西混分。 于是就有了：XXXXXXXXXXXXXXXXXX，求方案数。XXXXXXXXXXXXXXXXXX，求期望。我们假设还是能用类似的dp做。于是LZ可能就不服了：不公平！数学题！min有一个性质：min(a, b, c) = min(min(a, b), min(b, c))但是加法没有：a + b + c != (a + b) + (b + c)涉及到加法来把所有的解合并起来的东西，都要求你不重不漏，从而更有挑战性。并且避免了随机化骗分。 而且我觉得期望特别厉害，有一些min的性质：min(ka, kb) = kmin(a, b) =&gt; E(kX) = kE(X)min(a + x, a + y, b + x, b + y) = min(a, b) + min(x, y) =&gt; E(X + Y) = E(X) + E(Y)枚举最小答案判定是否有解 =&gt; EX = Pr(X &gt;= 0) + Pr(X &gt;= 1) + Pr(X &gt;= 2) + …所以期望有时候是绝佳的替代品。只要约定俗成假定各位OI选手都知道期望的性质。而事实上，我们高中课本上面还是提了几句的。（虽然讲得比较坑 = =……无力吐槽）如果你专注竞赛那么迟早会在做题中知道期望的性质，如果你专注文化课那么迟早会在数学课上遇见它。 所以我要是出题人，如果我想考dp，我肯定更愿意出方案数和期望，而不是最小值。这是真的是数学题吗？有时候看起来觉得显然是数学题的题目，只是信息学的包装。 再论实际用途。为什么快速排序的期望时间复杂度是O(n log n)而冒泡排序不是？为什么双旋splay的时间复杂度是均摊O(log n)而单旋的不是？为什么并查集的时间复杂度里有个某个阿克曼函数的反函数?为什么线段树的区间查询操作是O(log n)？我估计你没看过证明。不然就不会说出“只有复旦注重数学”。你说数据结构应该算纯信息学。那他的证明中可是货真价实的数学哦。我想问，难道那些发明这些科技的人是用一种“纯粹的算法能力”搞出这些东西，然后再马马虎虎糊弄一下数学证明的吗？显然不是。物理学中有一句令人印象深刻的道理：无论是什么奇谈怪论，只要他能用实验证明是对的，我们就接受他。实验是检验真理的唯一标准。你看，相对论那么颠覆性的东西现在也被人接受了。同样我们也可以说：既然数学给计算机带来了科技，带来了效率上的提升，那好，我们就可以认定数学是信息学思想的一部分。信息学需要数学，但不是纯数学里的数学，也不是物理里的数学。我认为基本上各个领域都需要数学作为支撑，只是用的方面不同。而我认为，信息学竞赛并不是在培养只会写代码的码农。是的，代码能力很重要，但并不只是这些。还是在培养的是能用信息学的思想去创造新的科技的计算机大师。 其实我曾经也一度对OI题中混入数学题感到愤怒。但是静下心来多接触一下我明白了其实并不是在考数学，那个东西就是信息学。 不知道你有没有知道昨天的题解。如果没有建议先去看看吧。仔细想想，于是你会明白没有人在用数学坑OIer。 （说句题外话，现役中小部分比如pyx、以及dzy loves math之流除外。你们都太神了 T_T） 不过我觉得质疑没有数据结构是对的啊。我赞同。但是我想说第三题的部分分里有树状数组。粗略点理解数据结构为何物，第二题的dp中用到了前缀和。（至少我用了……T_T）当然第一试没有出数据结构不代表第二试不会出。如果两试都出现了真数据结构题，那么我觉得是否太频繁了这个值得探讨。其实我觉得有时候数据结构题没出好就变成了裸题，OI赛场变成了打字比赛，AC者众。而且数据结构题的解集多半是多项式级的，而最优化问题、方案数、期望之类多半都是指数级的解集，从而更好出数据卡暴力。综上出题人觉得宁可不出数据结构。 这是我个人对于信息学的见解 = =……求轻喷。我真心希望湖北能出几位计算机大师而不是“为进省队头破血流者”。所以我才会说这么多…… 在这以前，只知道vfk是OI界的master，但是也仅仅是master罢了。 但是看了这段话，我才明白，oier刚开始学OI的目的是不太一样的，但是慢慢地，到了高中以后，竞赛性质凸显，功利化也在所难免。也许我们正在慢慢失去初心…… 初心难守是事实，但是也许就像vfk这样，越是厉害的人，越能懂得OI的意义所在。 对我而言，OI不仅仅是竞赛。OI还是生活。有时我会庆幸我当初没有去其他竞赛。或许我去搞数竞也能混得很好。但是可能又是一个完全不一样的世界了。 换句话说，我对我的现状不说很满足，但是满意了。毕竟我还有梦可追。I&#39;am still young. 以此共勉。活得不必很精彩，但至少要有意义。","tags":[]},{"title":"websites","date":"2019-03-16T13:26:26.995Z","path":"2019/03/16/websites/","text":"这里是一些有用的网站们： latex&amp;markdown相关： latex数学公式汇总 latex语法总结 latex记号一览 数学相关： oeis 某个数的性质 笛卡尔坐标系 数学系列 欧拉计划中文 pe题解 图相关： 建图和树 oi&amp;oj相关： atc数据 集训队作业部分题 图像处理相关： 图像放大 问题相关： stackoverflow","tags":[{"name":"网站","slug":"网站","permalink":"http://WHchuan123.github.io/tags/网站/"}]}]