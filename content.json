[{"title":"cf1140G","date":"2019-03-28T12:13:22.209Z","path":"2019/03/28/cf1140G/","text":"题意 给两棵同构的树，将同构节点之间连边，构成一张图。所有边有边权。给出一些询问，求某两点间的最短路。 题解 设两棵树分别为T,T′T, T&#x27;T,T′，同构节点们为x,x′x, x&#x27;x,x′。 注意到每个询问的答案一定是从uuu在某一棵树上走，然后走到另一棵树的同构节点，再在另外一棵树上走，这样的过程重复个若干次。 在一棵树上走一定是走简单路径；走到同构节点并非就是走那条直接相连的边，而是最短路。 先考虑最短路这么求？我们要求nnn对同构节点的最短路。 可以等价转化： 1.∀e(x,x′,wx)adde(0,x,wx)\\forall_{e(x, x&#x27;, w_x)}adde(0, x, w_x)∀e(x,x′,wx​)​adde(0,x,wx​) 2.∀e(x,y,w1,w2)adde(x,y,w1+w2)\\forall_{e(x, y, w_1, w_2)} adde(x, y, w_1 + w_2)∀e(x,y,w1​,w2​)​adde(x,y,w1​+w2​) 然后会发现这是对的……很神奇，就可以直接一遍sssp就好啦。 然后可以直接把最短路当做边权了。 那如何处理一整个问题？ 记录dpx,y,u,vdp_{x, y, u, v}dpx,y,u,v​代表从树uuu的节点xxx向上跳2y2 ^ y2y步且最终到达第v棵树上的最短路。其中u,vu, vu,v取值都是{0,1}\\{0, 1\\}{0,1}。发现可以把dpx,ydp_{x, y}dpx,y​看成一个2∗22 * 22∗2的矩阵。 为了方便，还要记录pdpdpd数组代表的是从上向下的最短路矩阵。 最后询问的时候倍增跳一跳，矩阵重定义运算一下，然后按顺序合并即可，注意合并的顺序。 复杂度O((n+Q)log⁡n)O((n + Q) \\log n)O((n+Q)logn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;typedef long long ll;inline int read () &#123; static int x; scanf(\"%lld\", &amp;x); return x;&#125;inline int readl () &#123; static ll x; scanf(\"%lld\", &amp;x); return x;&#125;const int N = 3e5 + 10, M = 2e6 + 10, H = 19;int n; ll D[N];struct Graph &#123; int n, tot; int lnk[N], nxt[M], son[M]; ll w[M]; void init (int _n) &#123; n = _n, tot = 1; memset(lnk, 0, sizeof lnk); &#125; void add (int x, int y, ll z) &#123; nxt[++tot] = lnk[x], lnk[x] = tot, son[tot] = y, w[tot] = z; &#125; void adde (int x, int y, ll z) &#123; add(x, y, z), add(y, x, z); &#125; void sssp () &#123; static ll dis[N]; static bool vis[N]; static queue &lt;int&gt; q; memset(dis, 60, sizeof dis), dis[0] = 0; memset(vis, 0, sizeof vis), vis[0] = 1; for ( ; !q.empty(); q.pop()); q.push(0); for ( ; !q.empty(); q.pop()) &#123; int x = q.front(); vis[x] = 0; for (int j = lnk[x]; j; j = nxt[j]) if (dis[son[j]] &gt; dis[x] + w[j]) &#123; dis[son[j]] = dis[x] + w[j]; if (!vis[son[j]]) vis[son[j]] = 1, q.push(son[j]); &#125; &#125; for (int i = 1; i &lt;= n; ++i) D[i] = dis[i]; &#125;&#125; G;struct Matrix &#123; ll a[2][2]; Matrix operator * (const Matrix &amp;o) &#123; return &#123;min(a[0][0] + o.a[0][0], a[0][1] + o.a[1][0]), min(a[0][0] + o.a[0][1], a[0][1] + o.a[1][1]), min(a[1][0] + o.a[0][0], a[1][1] + o.a[1][0]), min(a[1][0] + o.a[0][1], a[1][1] + o.a[1][1])&#125;; &#125;&#125;;struct Tree &#123; int n, tot; int lnk[N], nxt[N &lt;&lt; 1], son[N &lt;&lt; 1]; ll w1[N &lt;&lt; 1], w2[N &lt;&lt; 1]; int dep[N], fa[N][H + 1]; Matrix dp[N][H + 1], pd[N][H + 1]; void init (int _n) &#123; n = _n, tot = 1, dep[0] = 0; memset(lnk, 0, sizeof lnk); &#125; void add (int x, int y, ll z1, ll z2) &#123; nxt[++tot] = lnk[x], lnk[x] = tot, son[tot] = y, w1[tot] = z1, w2[tot] = z2; &#125; void adde (int x, int y, ll z1, ll z2) &#123; add(x, y, z1, z2), add(y, x, z1, z2); &#125; void dfs (int x, int p) &#123; fa[x][0] = p, dep[x] = dep[p] + 1; for (int j = lnk[x]; j; j = nxt[j]) if (son[j] != p) &#123; dfs(son[j], x); dp[son[j]][0] = &#123;w1[j], min(w1[j] + D[x], D[son[j]] + w2[j]), min(w1[j] + D[son[j]], D[x] + w2[j]), w2[j]&#125;; pd[son[j]][0] = &#123;w1[j], min(w1[j] + D[son[j]], D[x] + w2[j]), min(w1[j] + D[x], D[son[j]] + w2[j]), w2[j]&#125;; &#125; &#125; void build () &#123; for (int j = 1; j &lt;= H; ++j) for (int i = 1; i &lt;= n; ++i) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; dp[i][j] = dp[i][j - 1] * dp[fa[i][j - 1]][j - 1]; pd[i][j] = pd[fa[i][j - 1]][j - 1] * pd[i][j - 1]; &#125; &#125; int lca (int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); int dif = dep[x] - dep[y]; for (int j = H; ~j; --j) if (dif &gt;&gt; j &amp; 1) x = fa[x][j]; if (x == y) return x; for (int j = H; ~j; --j) if (fa[x][j] != fa[y][j]) x = fa[x][j], y = fa[y][j]; return fa[x][0]; &#125; ll query (int x, int y, int u, int v) &#123; static Matrix ans1, ans2, ans; ans1 = &#123;0, D[x], D[x], 0&#125;, ans2 = &#123;0, D[y], D[y], 0&#125;; int z = lca(x, y), dif; dif = dep[x] - dep[z]; for (int j = H; ~j; --j) if (dif &gt;&gt; j &amp; 1) ans1 = ans1 * dp[x][j], x = fa[x][j]; dif = dep[y] - dep[z]; for (int j = H; ~j; --j) if (dif &gt;&gt; j &amp; 1) ans2 = pd[y][j] * ans2, y = fa[y][j]; ans = ans1 * ans2; return ans.a[u][v]; &#125;&#125; T;signed main () &#123; n = read(), G.init(n), T.init(n); for (int i = 1; i &lt;= n; ++i) G.adde(0, i, readl()); for (int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); ll z1 = readl(), z2 = readl(); G.adde(x, y, z1 + z2), T.adde(x, y, z1, z2); &#125; G.sssp(); T.dfs(1, 0); T.build(); for (int _ = read(), x, y; _; --_) &#123; x = read() + 1, y = read() + 1; printf(\"%lld\\n\", T.query(x &gt;&gt; 1, y &gt;&gt; 1, x &amp; 1, y &amp; 1)); &#125; return 0;&#125; 不知为何全搞成long long才过。","tags":[{"name":"题解","slug":"题解","permalink":"http://WHchuan123.github.io/tags/题解/"},{"name":"数据结构","slug":"数据结构","permalink":"http://WHchuan123.github.io/tags/数据结构/"}]},{"title":"zjoi2019R1游记","date":"2019-03-25T11:17:50.805Z","path":"2019/03/25/zjoi2019R1游记/","text":"zjoi2019R1正在进行中…… 这大概是一篇回忆录啦。 回忆开始： Day -2 大概早早地就做着大巴车离开了xj……坐车的时候还是很激动的——又可以去玩了。但是事实上，大巴上极为无聊，还充斥着开车的叫声，坐着也很难受。 苟了2.5h后，终于到了镇海。 我们是先去的酒店。酒店一副中规中矩的样子，也并不差。 然后去参加了noip2018的颁奖典礼。没我啥事。 唯一的发现就是见到了fy本人。（演讲的气场好大） 晚上去填海食堂吃饭，发现xj包场二楼了。 晚上会宾馆颓颓颓，就不说了。 Day -1 今天有讲课很滋磁啊。到底讲什么呢？隐约感觉要讲杂题（那就给给了） 开始之后才发现是《具体数学》选讲，一看就来劲了。 然后发现下面一行字：镇海中学 罗煜翔 表示以前并未见过本人，只知道是个神仙。 真正讲课时发现和《具体数学》的关联不是特别大。主要的还是lyx本人的一些想法和套路的总结。感觉还可以吧，经过有一些听不懂的，但是还是见识到了神仙和他的一些想法。（课件里还有几道数学国集题，还是很滋磁的）上午也就这样。 下午很困。kcz将杂题。第一题看看不会然后就睡过去了。睡醒之后看了几道题，感觉没啥意思，然后就和小马哥下象棋了。（无限悔棋是谁想出来的？！） 晚上和毛哥一起回宾馆，途中感觉风特别冷（诡异？）。毛哥还觉得这个地方远不及江山城区那样热闹。在我看来那是必然。途中觉得xj其实很好，挺适合自己的，镇海这样的校园，反而有点让我这样的人无所适从。 Day 0 上午依然听讲课。范老师讲ds。 感觉xj的学长一个个都好牛逼啊，一个个上去秒题。 而我在下面自闭。太hard了。 听到AAA-tree就掉线了，尽管后面又重连了。 这远不如math来得清真，感觉自己这次省选的备考策略是很合理的。就紧紧抱着数学一条腿。（然而事实上我什么都没有复习） 中午吃饭的时候发现大家都自闭了，然后下午就组队会宾馆了。又是复习开车的好时光。颓了一下午。 晚上前半段继续打fifa。感觉自己的战术已经基本上成型了，面对top6不败。然而打利记的时候闪退了。自然是有不爽的，但是想想也就算了。毕竟是利记的球迷。看看表，时间不早了，就滚回去把隔膜都卸了。 尽管到现在还没复习任何东西，但是我其实心里不是很慌。 感觉明天的一切都是命运所决定的。做好准备，迎接挑战就行。 毕竟这代表着一个阶段学习的检验，无论结果如何，都应该认真对待。毕竟我们要活在未来才能活得更好。 Day 1","tags":[]},{"title":"随感","date":"2019-03-21T02:00:47.298Z","path":"2019/03/21/随感/","text":"最近心里颇不宁静 让我把心里想说的慢慢到来。 省选将近。 前几天想整理一下所学算法和模板，但是又有很多东西还不会，所以斟酌了好久，到底应该先做什么。 在询问了X大爷和M大爷之后，心中才有了确切的答案。再加上自己整理东西的心思真的很重，就开始了整理工作。 但是整理到后面发现排版很不舒服，而且放在博客上也不好看，便想到了做成ppt。ppt的形式是很美观的。然后就想到了“痴迷已久”的LaTeX\\LaTeXLATE​X。 鉴于之前听Ch大爷说过，LaTeX\\LaTeXLATE​X这东西贼难装。事实上也是这样。装了整整半天，大概吧（包括找模板之类的）。 装好后兴奋至极。以为一切都能顺利进行了。但是事实远超我的预料。我整理东西的速度太慢了：尽管说对语法掌握的还挺快的，但是效率就是低下。 今天上午，整理着，突然就不想整理了。然后就停下了手头的工作，也就有了这一篇文章。 至于为什么会不想整理，是因为我大概明白了，我整理的最初想法消失了：我把大量时间耗费在排版上。那有什么意思呢？ 然而思绪并未就此停止。 我又想起了之前那段时间，疯狂刷题，疯狂看课件，疯狂积累套路，疯狂写博客。事实就是那段时间的确成效很大，学了很多。但是回过来想，发现还是有很多自己忘了的，但又不会回去翻看。那有什么用呢？ 直到今天，我才意识到，博客与我，并不是一个写题解，讲套路的地方。像这样，仅仅是倾诉自己的想法，为自己提供所需，不挺好的吗？我认为博客中写题解或是记录学习笔记，对我自己而言，用处其实很小。更应该做的，应该是写一些好的idea，一些属于自己的东西。如果所有人的博客都是学习笔记或题解，都是烂大街的东西（当然人人都有自己的想法和看法，这不否定），写多了也没什么。不如取其精华，记录些好的想法吧。 我知道，我没有那些神仙所拥有的能力，但是只要我的思想是自由的，我就不差于他们。而如果只是一味的学习，我觉得也没多大意思。 毕竟学OI的目的，不在于能不能上清北。如果真是这样，那就完了。竞赛里的乐趣，绝不是从这种目标得来的。不如把一切都看清，看轻，幸福就会来临。是真的幸福而不是单纯的幸福感。 所以说，至少是现在，在我看来，打隔膜也没有整理这种无聊的东西颓到那里去。毕竟打隔膜是真的自己想做的事情，而整理知识资料这种事情，我想应该是强迫症在作祟吧。 wuyiqi爷说的一些话还是挺对的： 去做你发自内心想做的事情，别再犹豫。","tags":[]},{"title":"共勉","date":"2019-03-17T00:40:55.619Z","path":"2019/03/17/共勉/","text":"曾经在某吧里面看到了一个远古帖子，许多湖北省的oier在对省队选拔中出现的偏差非常不满。不管孰错孰对，vfk在那里说的一段话令我惊叹。惊叹后是沉思。 节选如下： 我认为信息学竞赛考察的是信息学的思想，为了考察思想就得用一些手段。举一个简单的例子：XXXXXXXXXXXXXXXXXX，求最小值。假设这题方法是dp。这是纯信息题，认同吧。但是这样有缺点：既然是最小值嘛，有人可以绕开dp，用随机化之类的东西混分。 于是就有了：XXXXXXXXXXXXXXXXXX，求方案数。XXXXXXXXXXXXXXXXXX，求期望。我们假设还是能用类似的dp做。于是LZ可能就不服了：不公平！数学题！min有一个性质：min(a, b, c) = min(min(a, b), min(b, c))但是加法没有：a + b + c != (a + b) + (b + c)涉及到加法来把所有的解合并起来的东西，都要求你不重不漏，从而更有挑战性。并且避免了随机化骗分。 而且我觉得期望特别厉害，有一些min的性质：min(ka, kb) = kmin(a, b) =&gt; E(kX) = kE(X)min(a + x, a + y, b + x, b + y) = min(a, b) + min(x, y) =&gt; E(X + Y) = E(X) + E(Y)枚举最小答案判定是否有解 =&gt; EX = Pr(X &gt;= 0) + Pr(X &gt;= 1) + Pr(X &gt;= 2) + …所以期望有时候是绝佳的替代品。只要约定俗成假定各位OI选手都知道期望的性质。而事实上，我们高中课本上面还是提了几句的。（虽然讲得比较坑 = =……无力吐槽）如果你专注竞赛那么迟早会在做题中知道期望的性质，如果你专注文化课那么迟早会在数学课上遇见它。 所以我要是出题人，如果我想考dp，我肯定更愿意出方案数和期望，而不是最小值。这是真的是数学题吗？有时候看起来觉得显然是数学题的题目，只是信息学的包装。 再论实际用途。为什么快速排序的期望时间复杂度是O(n log n)而冒泡排序不是？为什么双旋splay的时间复杂度是均摊O(log n)而单旋的不是？为什么并查集的时间复杂度里有个某个阿克曼函数的反函数?为什么线段树的区间查询操作是O(log n)？我估计你没看过证明。不然就不会说出“只有复旦注重数学”。你说数据结构应该算纯信息学。那他的证明中可是货真价实的数学哦。我想问，难道那些发明这些科技的人是用一种“纯粹的算法能力”搞出这些东西，然后再马马虎虎糊弄一下数学证明的吗？显然不是。物理学中有一句令人印象深刻的道理：无论是什么奇谈怪论，只要他能用实验证明是对的，我们就接受他。实验是检验真理的唯一标准。你看，相对论那么颠覆性的东西现在也被人接受了。同样我们也可以说：既然数学给计算机带来了科技，带来了效率上的提升，那好，我们就可以认定数学是信息学思想的一部分。信息学需要数学，但不是纯数学里的数学，也不是物理里的数学。我认为基本上各个领域都需要数学作为支撑，只是用的方面不同。而我认为，信息学竞赛并不是在培养只会写代码的码农。是的，代码能力很重要，但并不只是这些。还是在培养的是能用信息学的思想去创造新的科技的计算机大师。 其实我曾经也一度对OI题中混入数学题感到愤怒。但是静下心来多接触一下我明白了其实并不是在考数学，那个东西就是信息学。 不知道你有没有知道昨天的题解。如果没有建议先去看看吧。仔细想想，于是你会明白没有人在用数学坑OIer。 （说句题外话，现役中小部分比如pyx、以及dzy loves math之流除外。你们都太神了 T_T） 不过我觉得质疑没有数据结构是对的啊。我赞同。但是我想说第三题的部分分里有树状数组。粗略点理解数据结构为何物，第二题的dp中用到了前缀和。（至少我用了……T_T）当然第一试没有出数据结构不代表第二试不会出。如果两试都出现了真数据结构题，那么我觉得是否太频繁了这个值得探讨。其实我觉得有时候数据结构题没出好就变成了裸题，OI赛场变成了打字比赛，AC者众。而且数据结构题的解集多半是多项式级的，而最优化问题、方案数、期望之类多半都是指数级的解集，从而更好出数据卡暴力。综上出题人觉得宁可不出数据结构。 这是我个人对于信息学的见解 = =……求轻喷。我真心希望湖北能出几位计算机大师而不是“为进省队头破血流者”。所以我才会说这么多…… 在这以前，只知道vfk是OI界的master，但是也仅仅是master罢了。 但是看了这段话，我才明白，oier刚开始学OI的目的是不太一样的，但是慢慢地，到了高中以后，竞赛性质凸显，功利化也在所难免。也许我们正在慢慢失去初心…… 初心难守是事实，但是也许就像vfk这样，越是厉害的人，越能懂得OI的意义所在。 对我而言，OI不仅仅是竞赛。OI还是生活。有时我会庆幸我当初没有去其他竞赛。或许我去搞数竞也能混得很好。但是可能又是一个完全不一样的世界了。 换句话说，我对我的现状不说很满足，但是满意了。毕竟我还有梦可追。I&#39;am still young. 以此共勉。活得不必很精彩，但至少要有意义。","tags":[]},{"title":"websites","date":"2019-03-16T13:26:26.995Z","path":"2019/03/16/websites/","text":"这里是一些有用的网站们： latex&amp;markdown相关： latex数学公式汇总 latex语法总结 latex记号一览 数学相关： oeis 某个数的性质 笛卡尔坐标系 数学系列 欧拉计划中文 pe题解 图相关： 建图和树 oi&amp;oj相关： atc数据 集训队作业部分题 图像处理相关： 图像放大 问题相关： stackoverflow","tags":[{"name":"网站","slug":"网站","permalink":"http://WHchuan123.github.io/tags/网站/"}]}]