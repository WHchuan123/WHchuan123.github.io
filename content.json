[{"title":"算法总结","date":"2019-03-17T05:09:54.829Z","path":"2019/03/17/算法总结/","text":"数学 线性代数 矩阵乘法 一些有意思的东西（其实很naive）。 对于两个n×nn \\times nn×n的矩阵A,BA, BA,B，设C=ABC = ABC=AB考虑： 给AAA的最后加上一列1，BBB的最后加上一行1 ——等价于给CCC的每个元素+1； 给AAA的最后加上一行1，BBB的最后加上一列1 ——在Ci,n+1(1≤i≤n)​C_{i, n + 1}(1 \\le i \\le n)​Ci,n+1​(1≤i≤n)​存着A​A​A​的第i​i​i​行的和，在Cn+1,j(1≤j≤n)​C_{n + 1, j}(1 \\le j \\le n)​Cn+1,j​(1≤j≤n)​存着A​A​A​的第j​j​j​列的和。 尽管这在程序里并不是很需要，但是在手推式子的时候可以把上述操作用矩阵的语言表达。 拟阵 这是一个非常dark的东西。这里只介绍有限拟阵。 定义一个二元组M=(S,I)​M = (S, I)​M=(S,I)​满足： 1、SSS是一个有限集； 2、III是由SSS的一些子集组成的有限非空集合（即非空族），且III被称为SSS的独立子集； 3、∅∈I​\\emptyset \\in I​∅∈I​；（被称作独立集公理） 4、这个二元组具有遗传性：如果B∈I∧A⊆B​B \\in I \\land A \\subseteq B​B∈I∧A⊆B​，则有A∈I​A \\in I​A∈I​； 5、这个二元组具有交换性质：如果A∈I∧B∈I∧∣A∣&lt;∣B∣​A \\in I \\land B \\in I \\land |A| &lt; |B|​A∈I∧B∈I∧∣A∣&lt;∣B∣​，则∃x∈B−A​\\exist x \\in B - A​∃x∈B−A​使得A∪{x}∈I​A \\cup \\{x\\} \\in I​A∪{x}∈I​。（被称作独立扩充公理） 有一个非常形象的例子： 若M=(S,I)​M = (S, I)​M=(S,I)​是一个拟阵，其中： S={1,2,3},I={size≤2的子集}={∅,{1},{2},{3},{1,2},{1,3},{2,3}}S = \\lbrace 1, 2, 3\\rbrace, I = \\lbrace size \\leq 2的子集\\rbrace = \\lbrace \\emptyset, \\lbrace1\\rbrace, \\lbrace2\\rbrace, \\lbrace3\\rbrace, \\lbrace1, 2\\rbrace, \\lbrace1, 3\\rbrace, \\lbrace2, 3\\rbrace \\rbrace S={1,2,3},I={size≤2的子集}={∅,{1},{2},{3},{1,2},{1,3},{2,3}} 容易证明，这个系统是满足上述性质的，所以M=(S,I)​M = (S, I)​M=(S,I)​是拟阵这个命题为真。 有一个性质： 如果拟阵中的一个独立子集A​A​A​不存在扩展，那么就称它是极大的，且拟阵中所有极大的独立子集都具有相同大小（这个大小也称拟阵的秩）。这里的扩展的定义是指，将独立子集A​A​A​与这个扩展集合取并（有时扩展集合就是一个单一元素），新的集合依然是S​S​S​的独立子集。那么如果拟阵中的所有极大的独立子集不具有相同大小，那就可以用交换性质而推出大小较小者不是极大的结论，这显然是不对的。 再来讲一下一个关键的东西：加权拟阵。因为拟阵在OI里最大的用处是证明一些贪心，那么权值必然是需要的。 对于一个拟阵M=(S,I)​M = (S, I)​M=(S,I)​，如果用有一个权值函数w​w​w​关联了M​M​M​，并且对于S​S​S​中的每个元素x​x​x​都有w(x)&gt;0​w(x) &gt; 0​w(x)&gt;0​，则我们称这个拟阵是加权的。并且对于子集A​A​A​，其权值就是 w(A)=∑x∈Aw(x)w(A) = \\sum_{x \\in A}w(x) w(A)=x∈A∑​w(x) 考虑在贪心中使用拟阵。不妨考虑求的是最大权独立子集。 结论1：假定M=(S,I)​M = (S, I)​M=(S,I)​是一个加权拟阵，其加权函数为w​w​w​，且S​S​S​中所有元素已经按照权重从大到小排序了。令x​x​x​是S​S​S​中第一个满足{x}​\\{x\\}​{x}​独立的元素（如果存在），那么存在S​S​S​的一个最优独立子集A​A​A​包含x​x​x​。 证明？ 假设B​B​B​是任意非空的最优子集，且x∉B​x \\notin B​x∈/​B​。 对于任意y∈B​y \\in B​y∈B​，有w(y)≤w(x)​w(y) \\leq w(x)​w(y)≤w(x)​。 构造集合A={x}​A = \\{x\\}​A={x}​，根据独立扩充定理，可以反复地在B​B​B​中找出新元素加入A​A​A​直到∣A∣=∣B∣​|A| = |B|​∣A∣=∣B∣​，且保持A​A​A​是独立子集。 因此最后存在某个y∈B​y \\in B​y∈B​，使得A=(B−{y})∪{x}​A = (B - \\{y\\}) \\cup \\{x\\}​A=(B−{y})∪{x}​。 则有w(A)=w(B)−w(y)+w(x)≥w(B)​w(A) = w(B) - w(y) + w(x) \\ge w(B)​w(A)=w(B)−w(y)+w(x)≥w(B)​，命题得证。 结论2：若x​x​x​是我们在加权拟阵M=(S,I)​M = (S, I)​M=(S,I)​中第一个确定在最优解中的元素，则接下来的问题是寻找包含x​x​x​的一个最大权独立子集问题，可以归结于求加权拟阵M′=(S′,I′)​M&#x27;=(S&#x27;,I&#x27;)​M′=(S′,I′)​的一个最大权独立子集的问题。 其中S′={y∣ y∈S∧{x,y}∈I},I′={B∣B⊆S−{x}∧B∪{x}∈I}​S&#x27; = \\lbrace y | \\ y \\in S \\land \\lbrace x, y\\rbrace \\in I \\rbrace, I&#x27; = \\lbrace B | B \\subseteq S - \\lbrace x\\rbrace \\land B \\cup \\lbrace x\\rbrace \\in I\\rbrace​S′={y∣ y∈S∧{x,y}∈I},I′={B∣B⊆S−{x}∧B∪{x}∈I}​。 主要要证明两点： 1、在M′=(S′,I′)​M&#x27;= (S&#x27;, I&#x27;)​M′=(S′,I′)​中求得任意最优解X​X​X​均满足X∪{x}∈I​X \\cup \\{x\\} \\in I​X∪{x}∈I​； 2、在M=(S,I)​M = (S, I)​M=(S,I)​中包含x​x​x​的最优解X​X​X​一定可以表示为{x}∪X′​\\{x\\} \\cup X&#x27;​{x}∪X′​，其中X​X​X​是M′​M&#x27;​M′​的最优解。 这其实说明了拟阵优贪心最优子结构。 而实际是不会证明的 （其实这部分不会证明没关系） 至此我们就得出了一般的贪心算法了，很简单，就排个序，能取就去，不能取就不去，就没了。~~咕咕 应用： 最小生成树，最大权线性无关组…… 其实这些问题都有一个共性，就是关键的性质是有遗传性的，比如线性无关，比如不成环。 例如最小生成树问题： 已知N=(V,E)​N = (V, E)​N=(V,E)​，构造M=(S,I)​M = (S, I)​M=(S,I)​，其中S=E,I⊆2S​S = E, I \\subseteq 2 ^ S​S=E,I⊆2S​，且A∈I​A \\in I​A∈I​当且仅当A​A​A​构成的图是无环的。只需要证明M=(S,I)​M = (S, I)​M=(S,I)​是个拟阵即可。就满足最开始那几个性质和公理即可。 其实有限拟阵常见有很多，上面的线性基和最小生成树其实用到的分别是向量拟阵和图拟阵。其他还有组合拟阵，分割拟阵，环拟阵，匹配拟阵。 拟阵求交？求并？看了看不太会啊。 高代 对称差卷积FWT 即给定数组a,b​a, b​a,b​求 ck=∑i⊗j=kaibjc_k = \\sum_{i \\otimes j = k} a_i b_j ck​=i⊗j=k∑​ai​bj​ 这个东西和FFT一样建立在卷积定理的基础上。 做这个东西本质上是一个构造的方法。规定一些符号：(A,B)(A, B)(A,B)表示将数组A,BA, BA,B顺次连接组成的新数组。为了方便，假设a,b,ca,b,ca,b,c的长度都是2的幂次。 我们考虑分治递归着做，使得最后构造出的东西满足卷积定理： tf(f⊗g)=tf(f)×tf(g)tf(f \\otimes g) = tf(f) \\times tf(g) tf(f⊗g)=tf(f)×tf(g) 则可以这样： tf(f)=(tf(f0−f1),tf(f0+f1))tf(f) = (tf(f_0 - f_1), tf(f_0 + f_1)) tf(f)=(tf(f0​−f1​),tf(f0​+f1​)) 其中f0,f1​f_0, f_1​f0​,f1​​分别表示f​f​f​的前一半和后一半。而如果∣f∣=1​|f| = 1​∣f∣=1​，那么规定tf(f)=f​tf(f) = f​tf(f)=f​。 则可以证明构造出来的tf​tf​tf​变化是满足卷积定理的。 证明如下（用归纳）： tf(f⊗g)=tf((f0,f1)⊗(g0,g1))=tf(f0⊗g0+f1⊗g1,f0⊗g1+f1⊗g0)(由对称差卷积的定义得)=tf(f0⊗g0+f1⊗g1,f0⊗g1+f1⊗g0)=tf(f0⊗g0+f1⊗g1−f0⊗g1−f1⊗g0,f0⊗g0+f1⊗g1+f0⊗g1+f1⊗g0)=(tf((f0−f1)⊗(g0−g1)),tf((f0+f1)⊗(g0+g1)))=(tf(f0−f1)×tf(g0−g1),tf(f0+f1)×tf(g0+g1))=(tf(f0−f1),tf(f0+f1))×(tf(g0−g1)×tf(g0+g1))=tf(f)×tf(g)\\begin{aligned} tf(f \\otimes g) &amp; = tf((f_0, f_1) \\otimes (g_0, g_1)) \\\\ &amp; = tf(f_0 \\otimes g_0 + f_1 \\otimes g_1, f_0 \\otimes g_1 + f_1 \\otimes g_0) (由对称差卷积的定义得) \\\\ &amp; = tf(f_0 \\otimes g_0 + f_1 \\otimes g_1, f_0 \\otimes g_1 + f_1 \\otimes g_0) \\\\ &amp; = tf(f_0 \\otimes g_0 + f_1 \\otimes g_1 - f_0 \\otimes g_1 - f_1 \\otimes g_0, f_0 \\otimes g_0 + f_1 \\otimes g_1 + f_0 \\otimes g_1 + f_1 \\otimes g_0) \\\\ &amp; = (tf((f_0 - f_1) \\otimes (g_0 - g_1)), tf((f_0 + f_1) \\otimes (g_0 + g_1))) \\\\ &amp; = (tf(f_0 - f_1) \\times tf(g_0 - g_1), tf(f_0 + f_1) \\times tf(g_0 + g_1)) \\\\ &amp; = (tf(f_0 - f_1), tf(f_0 + f_1)) \\times (tf(g_0 - g_1) \\times tf(g_0 + g_1)) \\\\ &amp; = tf(f) \\times tf(g) \\end{aligned} tf(f⊗g)​=tf((f0​,f1​)⊗(g0​,g1​))=tf(f0​⊗g0​+f1​⊗g1​,f0​⊗g1​+f1​⊗g0​)(由对称差卷积的定义得)=tf(f0​⊗g0​+f1​⊗g1​,f0​⊗g1​+f1​⊗g0​)=tf(f0​⊗g0​+f1​⊗g1​−f0​⊗g1​−f1​⊗g0​,f0​⊗g0​+f1​⊗g1​+f0​⊗g1​+f1​⊗g0​)=(tf((f0​−f1​)⊗(g0​−g1​)),tf((f0​+f1​)⊗(g0​+g1​)))=(tf(f0​−f1​)×tf(g0​−g1​),tf(f0​+f1​)×tf(g0​+g1​))=(tf(f0​−f1​),tf(f0​+f1​))×(tf(g0​−g1​)×tf(g0​+g1​))=tf(f)×tf(g)​ 命题得证。 同理，可以定义逆变换 utf(f⊗g)=(utf(f0+f12),utf(f0−f12))utf(f \\otimes g) = (utf(\\frac {f_0+f_1}{2}), utf(\\frac {f_0-f_1}{2})) utf(f⊗g)=(utf(2f0​+f1​​),utf(2f0​−f1​​)) 只要证明这个逆变换满足 utf((tf(f0+f1),tf(f0−f1)))=futf((tf(f_0+f_1), tf(f_0 - f_1))) = f utf((tf(f0​+f1​),tf(f0​−f1​)))=f 即可。 事实上，tf(f+g)=tf(f)+tf(g)tf(f + g) = tf(f) + tf(g)tf(f+g)=tf(f)+tf(g)也是恒成立的。 因此可以改写式子： tf(f)=(tf(f0−f1),tf(f0+f1))=(tf(f0)−tf(f1),tf(f0)+tf(f1))tf(f) = (tf(f_0 - f_1), tf(f_0 + f_1)) = (tf(f_0) - tf(f_1), tf(f_0) + tf(f_1)) tf(f)=(tf(f0​−f1​),tf(f0​+f1​))=(tf(f0​)−tf(f1​),tf(f0​)+tf(f1​)) 组合计数 反演 反演的本质。 已知：f(n)=∑i=0nan,ig(i)​f(n) = \\sum_{i = 0} ^ n a_{n, i} g(i)​f(n)=∑i=0n​an,i​g(i)​ 即： \\begin{pmatrix} f(0)\\\\ f(1)\\\\ f(2)\\\\ \\vdots\\\\ f(n) \\end{pmatrix}= \\begin{pmatrix} a_{0,0}&amp;0&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{1,0}&amp;a_{1,1}&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{2,0}&amp;a_{2,1}&amp;a_{2,2}&amp;0&amp;\\cdots&amp;0\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ a_{n,0}&amp;a_{n,1}&amp;a_{n,2}&amp;a_{n,3}&amp;\\cdots&amp;a_{n,n}\\\\ \\end{pmatrix} \\begin{pmatrix} g(0)\\\\\\ g(1)\\\\\\ g(2)\\\\\\ \\vdots\\\\\\ g(n) \\end{pmatrix} 反演即是求：g(n)=∑i=0nbn,if(i)​g(n) = \\sum_{i = 0} ^ n b_{n, i}f(i)​g(n)=∑i=0n​bn,i​f(i)​ 考虑f(n)=∑i=0nan,i∑j=0ibi,jf(j)​f(n) = \\sum_{i = 0} ^ n a_{n, i} \\sum_{j = 0} ^ i b_{i, j} f(j)​f(n)=∑i=0n​an,i​∑j=0i​bi,j​f(j)​，也就是下面这个矩阵中所有元素之和： (an,0b0,0f(0)000⋯0an,1b1,0f(0)an,1b1,1f(1)00⋯0an,2b2,0f(0)an,2b2,1f(1)an,2b2,2f(2)0⋯0⋮⋮⋮⋮⋱⋮an,nbn,0f(0)an,nbn,1f(1)an,nbn,2f(2)an,nbn,3f(3)⋯an,nbn,nf(n))\\begin{pmatrix} a_{n,0}b_{0,0}f(0)&amp;0&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{n,1}b_{1,0}f(0)&amp;a_{n,1}b_{1,1}f(1)&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{n,2}b_{2,0}f(0)&amp;a_{n,2}b_{2,1}f(1)&amp;a_{n,2}b_{2,2}f(2)&amp;0&amp;\\cdots&amp;0\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ a_{n,n}b_{n,0}f(0)&amp;a_{n,n}b_{n,1}f(1)&amp;a_{n,n}b_{n,2}f(2)&amp;a_{n,n}b_{n,3}f(3)&amp;\\cdots&amp;a_{n,n}b_{n,n}f(n)\\\\ \\end{pmatrix} ⎝⎜⎜⎜⎜⎜⎛​an,0​b0,0​f(0)an,1​b1,0​f(0)an,2​b2,0​f(0)⋮an,n​bn,0​f(0)​0an,1​b1,1​f(1)an,2​b2,1​f(1)⋮an,n​bn,1​f(1)​00an,2​b2,2​f(2)⋮an,n​bn,2​f(2)​000⋮an,n​bn,3​f(3)​⋯⋯⋯⋱⋯​000⋮an,n​bn,n​f(n)​⎠⎟⎟⎟⎟⎟⎞​ 又因为f(n)=∑j=0nf(j)∑i=jnan,ibi,jf(n) = \\sum_{j = 0} ^ n f(j) \\sum_{i = j} ^ n a_{n, i}b_{i, j}f(n)=∑j=0n​f(j)∑i=jn​an,i​bi,j​，所以如果能构造出b​b​b​矩阵满足 ∑i=jnan,ibi,j={1,j=n0,j≠n\\sum_{i = j} ^ n a_{n, i}b_{i, j} = \\begin{cases} 1, &amp; j = n \\\\ 0, &amp; j \\neq n \\\\ \\end{cases} i=j∑n​an,i​bi,j​={1,0,​j=nj​=n​ 即 ∑i=jnan,ibi,j=[j==n]\\sum_{i = j} ^ n a_{n, i} b_{i, j} = [j == n] i=j∑n​an,i​bi,j​=[j==n] 就可以愉快地反演啦！因为这个式子知道了aaa矩阵就可以逐行递推出bbb矩阵，递推顺序见下（以4×4矩阵为例）： 40007300962010851\\begin{matrix} 4 &amp; 0 &amp; 0 &amp; 0 \\\\ 7 &amp; 3 &amp; 0 &amp; 0 \\\\ 9 &amp; 6 &amp; 2 &amp; 0 \\\\ 10 &amp; 8 &amp; 5 &amp; 1 \\\\ \\end{matrix} 47910​0368​0025​0001​ 其中000的位置代表值为000，也就是我们不需要计算。 数据结构 动态树(link-cut-tree) 沿用树链剖分思想，只是构建了辅助树。辅助树由多棵splay组成，每棵splay通过实边维护重链，中序遍历的话正好是链头到链尾的节点；splay之间通过虚边维护轻边，虚边上的父节点正是轻边上的父节点，但轻边上的子节点是以虚边上的子节点为根的splay中中序遍历最小的点。 辅助函数： Nonroot(x) 作用：判断xxx是否为非splay根的节点。 实现： 1234&gt; bool Nonroot (int x) &#123;&gt; return lc[fa[x]] == x || rc[fa[x]] == x;&gt; &#125;&gt; Side(x) 作用：判断x​x​x​是其父节点的左(0)/右(1)子树。 实现： 1234&gt; bool Side (int x) &#123;&gt; return rc[fa[x]] == x;&gt; &#125;&gt; Pushup(x) 作用：上传x​x​x​子节点信息。 实现： 1234&gt; void Pushup (int x) &#123;&gt; ...&gt; &#125;&gt; Pushrev(x) 作用：下传xxx的rev标记。 实现： 1234&gt; void Pushrev (int x) &#123;&gt; swap(lc[x], rc[x]), r[x] ^= 1;&gt; &#125;&gt; Pushdown(x) 作用：下传xxx的懒标记。 实现： 12345678&gt; void Pushdown (int x) &#123;&gt; if (rev[x]) &#123;&gt; if (lc[x]) Pushrev(lc[x]);&gt; if (rc[x]) Pushrev(rc[x]);&gt; rev[x] = 0;&gt; &#125;&gt; &#125;&gt; 主要操作函数： Rotate(x) 作用：将x​x​x​向根方向旋转一次。 实现： 123456789&gt; void Rotate (int x) &#123;&gt; int y = fa[x], z = fa[y], sx = Side(x), sy = Side(y);&gt; if (Nonroot(y)) c(z, sy) = x;&gt; fa[x] = z;&gt; fa[c(y, sx) = c(x, sx ^ 1)] = y;&gt; fa[c(x, sx ^ 1) = y] = x;&gt; Pushup(y), Pushup(x);&gt; &#125;&gt; Splay(x)​ 作用：将xxx旋转到其所在splay树的根节点。 实现： 12345678910&gt; int st[N];&gt; void Splay (int x) &#123;&gt; st[st[0] = 1] = x;&gt; for (int y = x; Nonroot(y); y = fa[y]) st[++st[0]] = fa[y];&gt; for ( ; st[0]; --st[0]) Pushdown(st[st[0]]);&gt; for (int y = fa[x]; Nonroot(x); Rotate(x), y = fa[x])&gt; if (Nonroot(y)) Rotate(Side(x) ^ Side(y) ? x : y);&gt; Pushup(x);&gt; &#125;&gt; Access(x) 作用：将xxx到原树根的路径上的边都变为重边，且xxx到其原来的重儿子的边变成轻边。 实现： 12345&gt; void Access (int x) &#123;&gt; for (int y = 0; x; y = x, x = fa[x])&gt; Splay(x), rc[x] = y, Pushup(x);&gt; &#125;&gt; Makeroot(x)​ 作用：将原树的根换成点xxx。 实现： 1234&gt; void Makeroot (int x) &#123;&gt; Access(x), Splay(x), Pushrev(x);&gt; &#125;&gt; Findroot(x)​ 作用：找到xxx所在原树的树根（主要用来判断连通性）。 实现： 1234567&gt; void Findroot (int x) &#123;&gt; Access(x), Splay(x);&gt; for ( ; lc[x]; x = lc[x]) Pushdown(x);&gt; Splay(x);&gt; return x;&gt; &#125;&gt; Split(x, y)​ 作用：将路径x−yx - yx−y拉出，使x,yx, yx,y在一棵splay中（直接查询yyy就可以知道该路径的有关信息）。 实现： 1234&gt; void Split (int x, int y) &#123;&gt; Makeroot(x), Access(y), Splay(y);&gt; &#125;&gt; Link(x, y)​ 作用：连一条x−yx - yx−y的边（如果本来就在一棵树中会return 0）。 实现： 1234&gt; void Link (int x, int y) &#123;&gt; Makeroot(x), fa[x] = y;&gt; &#125;&gt; Cut(x, y) 作用：将边x−yx - yx−y断开。 实现： 12345&gt; void Cut (int x, int y) &#123;&gt; Makeroot(x), Access(y), Splay(y);&gt; lc[y] = fa[x] = 0, Pushup(y);&gt; &#125;&gt; 其他 动态dp 在树（或动态树）上做一类dp，支持单点修改，单点查询。 如果没有修改，可以写出一般的转移方程；但一旦有修改就做不了。 考虑对树进行树链剖分。 对于一个节点有轻重儿子，可以写出关于轻重儿子的转移方程（一般轻儿子的信息可以叠加，可以维护和来处理） 然后对发现是一个类似矩阵乘法的转移。 这里可能要定义新运算⊗​\\otimes​⊗​和⊕​\\oplus​⊕​。 比如树上最大带权独立集， 设fx​f_x​fx​​为表示点x的最大权独立集，gx​g_x​gx​​表示点x不选，其子树的最大权独立集。再设h(x)​h(x)​h(x)​表示点x的重儿子，lfx​lf_x​lfx​​表示x所有轻儿子的f​f​f​ 值的和，lgx​lg_x​lgx​​类似。 则我们可以写出转移： fx=max{gx,lgx+gh(x)+vx}gx=lfx+fh(x)\\begin{aligned} &amp; f_x = max\\{g_x , lg_x + g_{h(x)} + v_x \\} \\\\ &amp; g_x = lf_x + f_{h(x)} \\end{aligned} ​fx​=max{gx​,lgx​+gh(x)​+vx​}gx​=lfx​+fh(x)​​ 然后令x⊗y=x+y​x \\otimes y = x + y​x⊗y=x+y​，x⊕y=max{x,y}​x \\oplus y = max\\{x, y\\}​x⊕y=max{x,y}​，其中x,y​x, y​x,y​是普通的数。我们发现新的运算是结合的且封闭的，那么就可以做矩阵乘法了。并且矩阵乘法中的乘变成了⊗​\\otimes​⊗​，加变成了⊕​\\oplus​⊕​。 则转移变成： [lfxlgx⊗vxlfx−∞][fh(x)gh(x)]=[(lfx⊗fh(x))⊕(lgx⊗vx⊗gh(x))lfx⊗fh(x)]\\left[ \\begin{matrix} lf_x &amp; lg_x \\otimes v_x \\\\ lf_x &amp; -\\infin \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} f_{h(x)} \\\\ g_{h(x)} \\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} (lf_x \\otimes f_{h(x)}) \\oplus (lg_x \\otimes v_x \\otimes g_{h(x)}) \\\\ lf_x \\otimes f_{h(x)} \\\\ \\end{matrix} \\right] [lfx​lfx​​lgx​⊗vx​−∞​][fh(x)​gh(x)​​]=[(lfx​⊗fh(x)​)⊕(lgx​⊗vx​⊗gh(x)​)lfx​⊗fh(x)​​] 其中用到了运算规律： x⊗0=0⊗x=xx⊕−∞=−∞⊕x=x\\begin{aligned} &amp; x \\otimes 0 = 0 \\otimes x = x \\\\ &amp; x \\oplus -\\infin = -\\infin \\oplus x = x \\end{aligned} ​x⊗0=0⊗x=xx⊕−∞=−∞⊕x=x​ 可以看出在这里000是乘法单位元，−∞-\\infin−∞是加法单位元。 然后可以对于每一条重链维护这条重链上点的转移矩阵的乘积。 轻边会在树剖做第二次dfs的时候直接暴力合并上来。就是说，第二次dfs的时候要处理出每个点的转移矩阵，且这个转移矩阵不能把该点的重儿子的贡献算上。但是注意，一个节点的轻儿子的重儿子这种贡献还是会要加入这个节点的转移矩阵的。 单点修改的时候，把向上涉及到的重链都修改掉，遇到轻边就暴力改轻边连上去的节点。 然后查询某一点的dp值即把这个点到这个点所在重链的最深的点的转移矩阵用线段树乘起来即可。注意乘的顺序。 对于本题，复杂度就是O(23nlog⁡n)​O(2 ^ 3 n \\log n)​O(23nlogn)​。可以看出，动态dp需要dp数组维护的种类比较少。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://WHchuan123.github.io/tags/笔记/"},{"name":"算法","slug":"算法","permalink":"http://WHchuan123.github.io/tags/算法/"}]},{"title":"定理汇总","date":"2019-03-17T05:09:54.818Z","path":"2019/03/17/定理汇总/","text":"数学 线性代数 矩阵树定理(Matrix-Tree)： 对于一个无向图GGG，它的生成树个数等于其基尔霍夫(Kirchhoff)矩阵任何一个n−1n-1n−1阶主子式的行列式的绝对值。 n−1n-1n−1阶主子式就是对于一个任意的一个rrr，将矩阵的第rrr行和第rrr列同时删去得到的新矩阵。 其中，基尔霍夫矩阵K​K​K​=度数矩阵D​D​D​-邻接矩阵A​A​A​。 推广：统计所有生成树边权乘积的和 由于矩阵树定理是可以用于有重边的图的，所以一条边(x,y,z)(x, y, z)(x,y,z)可以看做(x,y)(x, y)(x,y)间增加了zzz条边。还是套用矩阵树即可。 柯西-比内公式(Binet-Cauchy)： 对于一个m×nm \\times nm×n的矩阵AAA和一个n×mn \\times mn×m的矩阵BBB，相乘可以得到m×mm \\times mm×m的矩阵CCC。 记[n]​[n]​[n]​为集合{1,2,...,n}​\\{1, 2, ..., n\\}​{1,2,...,n}​，([n]m)​\\binom {[n]}{m}​(m[n]​)​为[n]​[n]​[n]​中无序取出m​m​m​个元素所得的集合族（其大小恰为(nm)​\\binom {n}{m}​(mn​)​）。 则 det⁡C=∑∣S∣∈([n]m)det⁡A[m],S⋅det⁡BS,[m]\\det C = \\sum_{|S| \\in \\binom {[n]}{m}} \\det A_{[m], S} \\cdot \\det B_{S, [m]} detC=∣S∣∈(m[n]​)∑​detA[m],S​⋅detBS,[m]​ 推论： 若m&gt;n​m &gt; n​m&gt;n​，则det⁡C=0​\\det C= 0​detC=0​； 若m=n​m = n​m=n​，则det⁡C=det⁡A⋅det⁡B​\\det C = \\det A \\cdot \\det B​detC=detA⋅detB​； 若m&lt;nm &lt; nm&lt;n，则只能通过上式计算。 当nnn和mmm差不大时比较有用。 注意：这个公式对矩阵元素取值于任何交换环都成立。 拟阵中的最大最小定理： 对于两个定义在同一个全集U​U​U​上的拟阵M1=(U,I1),M2=(U,I2)​M_1 = (U, I_1), M_2 = (U, I_2)​M1​=(U,I1​),M2​=(U,I2​)​，有 max⁡I∈I1∩I2∣I∣=min⁡S∈Ur1(S)+r2(U∖S)\\max_{I \\in I_1 \\cap I_2} |I| = \\min_{S \\in U} r_1(S) + r2(U \\setminus S) I∈I1​∩I2​max​∣I∣=S∈Umin​r1​(S)+r2(U∖S) 证明是不会的，会了也会忘，只知道这个可以用来证明拟阵求交的正确性。 高代 卷积定理： 对于任意变换TTT和任意集合A,BA, BA,B，如果有 T(A)⋅T(B)=T(A∗B)T(A) \\cdot T(B) = T(A * B) T(A)⋅T(B)=T(A∗B) 则称变换TTT对于卷积∗*∗满足卷积定理。 组合计数 容斥原理： ∣⋃i=1nAi∣=∑T⊆S,∣S∣&gt;0(−1)∣T∣−1∣⋂j∈TAj∣(S={1,2,..n})|\\bigcup_{i = 1} ^ n A_i| = \\sum_{T \\subseteq S, |S| &gt; 0} (-1) ^ {|T| - 1} |\\bigcap_{j \\in T} A_j| \\quad (S = \\{1, 2, ..n\\}) ∣i=1⋃n​Ai​∣=T⊆S,∣S∣&gt;0∑​(−1)∣T∣−1∣j∈T⋂​Aj​∣(S={1,2,..n}) 另一种形式： ∣⋂i=1nAi‾∣=∑T⊆S(−1)∣T∣−1∣⋂j∈TAj∣(S={1,2,..n})|\\bigcap_{i = 1} ^ n \\overline {A_i}| = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1} |\\bigcap_{j \\in T} A_j| \\quad (S = \\{1, 2, ..n\\}) ∣i=1⋂n​Ai​​∣=T⊆S∑​(−1)∣T∣−1∣j∈T⋂​Aj​∣(S={1,2,..n}) 其中，0个集合的交是全集UUU。 min-max容斥： 给定集合SSS，设max⁡(S)\\max(S)max(S)为SSS中元素最大值，min⁡(S)\\min(S)min(S)为SSS中的最小值，则有： max⁡(S)=∑T⊆S(−1)∣T∣−1min⁡(T)\\max(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}\\min(T) max(S)=T⊆S∑​(−1)∣T∣−1min(T) 推广： kthmax⁡(S)=∑T⊆S(−1)∣T∣−k(∣T∣−1k−1)min(T)kth\\max(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - k} \\binom {|T| - 1}{k - 1}min(T) kthmax(S)=T⊆S∑​(−1)∣T∣−k(k−1∣T∣−1​)min(T) 推论： lcm(S)=∑T⊆S(−1)∣T∣−1gcd(T)lcm(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}gcd(T) lcm(S)=T⊆S∑​(−1)∣T∣−1gcd(T) 反演： 莫比乌斯反演： f(n)=∑d∣ng(d)⟺g(n)=∑d∣nμ(d)f(nd)f(n)=∑n∣dg(d)⟺g(n)=∑n∣dμ(dn)f(d)f(n) = \\sum_{d | n} g(d) \\Longleftrightarrow g(n) = \\sum_{d | n} \\mu(d) f(\\frac {n}{d}) \\\\ f(n) = \\sum_{n | d} g(d) \\Longleftrightarrow g(n) = \\sum_{n | d} \\mu(\\frac {d}{n}) f(d) \\\\ f(n)=d∣n∑​g(d)⟺g(n)=d∣n∑​μ(d)f(dn​)f(n)=n∣d∑​g(d)⟺g(n)=n∣d∑​μ(nd​)f(d) 关键： [n==1]⇔∑d∣nμ(d)[n == 1] \\Leftrightarrow \\sum_{d | n} \\mu(d) [n==1]⇔d∣n∑​μ(d) 二项式反演： f(n)=∑i=0n(ni)g(i)⟺g(n)=∑i=0n(ni)(−1)n−if(i)f(n) = \\sum_{i = 0} ^ n \\binom {n}{i} g(i) \\Longleftrightarrow g(n) = \\sum_{i = 0} ^ n \\binom {n}{i} (-1) ^ {n - i} f(i) f(n)=i=0∑n​(in​)g(i)⟺g(n)=i=0∑n​(in​)(−1)n−if(i) 关键： [n==0]⇔(1−1)n⇔∑i=0n(−1)i[n == 0] \\Leftrightarrow (1 - 1) ^ n \\Leftrightarrow \\sum_{i = 0} ^ n (-1) ^ i [n==0]⇔(1−1)n⇔i=0∑n​(−1)i 最值反演： max⁡(S)=∑T⊆S(−1)∣T∣−1min⁡(T)⟺min⁡(S)=∑T⊆S(−1)∣T∣−1max⁡(T)\\max(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}\\min(T) \\Longleftrightarrow \\min(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}\\max(T) max(S)=T⊆S∑​(−1)∣T∣−1min(T)⟺min(S)=T⊆S∑​(−1)∣T∣−1max(T) 关键： [S==∅]⇔∑T⊆S(−1)∣S∣−∣T∣min(S)=∑T⊆S(−1)∣T∣−∣S∣min(T)[S==T][S == \\emptyset] \\Leftrightarrow \\sum_{T \\subseteq S} (-1) ^ {|S| - |T|} \\\\ min(S) = \\sum_{T \\subseteq S}(-1) ^ {|T| - |S|}min(T)[S == T] [S==∅]⇔T⊆S∑​(−1)∣S∣−∣T∣min(S)=T⊆S∑​(−1)∣T∣−∣S∣min(T)[S==T] 斯特林反演（并不会推）： f(n)=∑i=0ns1(n,i)g(i)⟺g(n)=∑i=0ns2(n,i)(−1)n−if(i)f(n)=∑i=0ns2(n,i)g(i)⟺g(n)=∑i=0ns1(n,i)(−1)n−if(i)f(n) = \\sum_{i = 0} ^ n s_1(n, i)g(i) \\Longleftrightarrow g(n) = \\sum_{i = 0} ^ n s_2(n, i)(-1) ^ {n - i} f(i) \\\\ f(n) = \\sum_{i = 0} ^ n s_2(n, i)g(i) \\Longleftrightarrow g(n) = \\sum_{i = 0} ^ n s_1(n, i)(-1) ^ {n - i} f(i) f(n)=i=0∑n​s1​(n,i)g(i)⟺g(n)=i=0∑n​s2​(n,i)(−1)n−if(i)f(n)=i=0∑n​s2​(n,i)g(i)⟺g(n)=i=0∑n​s1​(n,i)(−1)n−if(i) 关键： ∑i=1ns1(n,k)s2(k,m)(−1)n−k=[m==n]∑i=1ns2(n,k)s1(k,m)(−1)n−k=[m==n]\\sum_{i = 1} ^ n s_1(n, k) s_2(k, m) (-1) ^ {n - k} = [m == n] \\\\ \\sum_{i = 1} ^ n s_2(n, k) s_1(k, m) (-1) ^ {n - k} = [m == n] i=1∑n​s1​(n,k)s2​(k,m)(−1)n−k=[m==n]i=1∑n​s2​(n,k)s1​(k,m)(−1)n−k=[m==n] 单位根反演（FFT里面要用的东西）： f(n)=∑i=0n−1ωnnig(i)⟺g(n)=1n∑i=0n−1ωn−nif(i)f(n) = \\sum_{i = 0} ^ {n - 1} \\omega_n ^ {ni} g(i) \\Longleftrightarrow g(n) = \\frac {1}{n} \\sum_{i = 0} ^ {n - 1} \\omega_n ^ {-ni} f(i) f(n)=i=0∑n−1​ωnni​g(i)⟺g(n)=n1​i=0∑n−1​ωn−ni​f(i) 关键： [k∣n]=1k∑i=0k−1ωkni[k | n] = \\frac {1}{k} \\sum_{i = 0} ^ {k - 1} \\omega_k ^ {ni} [k∣n]=k1​i=0∑k−1​ωkni​ 子集反演： f(S)=∑T⊆Sg(T)⟺g(S)=∑T⊆S(−1)∣S∣−∣T∣f(T)f(S) = \\sum_{T \\subseteq S} g(T) \\Longleftrightarrow g(S) = \\sum_{T \\subseteq S}(-1) ^ {|S| - |T|}f(T) f(S)=T⊆S∑​g(T)⟺g(S)=T⊆S∑​(−1)∣S∣−∣T∣f(T) 关键： [S==∅]⇔∑T⊆S(−1)∣S∣−∣T∣[S == \\emptyset] \\Leftrightarrow \\sum_{T \\subseteq S} (-1) ^ {|S| - |T|} [S==∅]⇔T⊆S∑​(−1)∣S∣−∣T∣ 概率和期望 期望的积分式： E=∫0+∞P(x)dx（连续型）E=∑i=0nP(i)(离散型)E = \\int_0 ^ {+\\infty} P(x)dx（连续型）\\\\ E = \\sum_{i = 0} ^ n P(i) (离散型) E=∫0+∞​P(x)dx（连续型）E=i=0∑n​P(i)(离散型) 某定理： 对于nnn个[0,1][0,1][0,1]之间的随机变量x1,x2,...,xnx_1,x_2,...,x_nx1​,x2​,...,xn​，第kkk小的那个的期望值是kn+1\\frac {k}{n+1}n+1k​。 条件概率： 定理P(A∣B)P(A|B)P(A∣B)为BBB已经发生的基础上，AAA发生的概率。 则有 1.定义得出： P(A∣B)=P(AB)P(B)P(A|B) = \\frac{P(AB)}{P(B)} P(A∣B)=P(B)P(AB)​ 2.类似于容斥原理（AB​AB​AB​即A∩B​A \\cap B​A∩B​）： P(AB)=P(A)+P(B)−P(A∪B)P(AB) = P(A) + P(B) - P(A \\cup B) P(AB)=P(A)+P(B)−P(A∪B) 3.全概率公式（其中∀i=j,Bi∩Bj=∅​\\forall i \\not= j, B_i \\cap B_j = \\emptyset​∀i​=j,Bi​∩Bj​=∅​，且∑P(Bk)=1​\\sum P(B_k) = 1​∑P(Bk​)=1​）： P(A)=∑P(A∣Bk)P(Bk)P(A) = \\sum P(A|B_k)P(B_k) P(A)=∑P(A∣Bk​)P(Bk​) 4.贝叶斯公式： P(A∣B)=P(B∣A)P(A)P(B)P(A|B) = \\frac{P(B|A)P(A)}{P(B)} P(A∣B)=P(B)P(B∣A)P(A)​ 期望相关： 若两个变量X,Y​X, Y​X,Y​独立，则E(XY)=E(X)E(Y)​E(XY) = E(X)E(Y)​E(XY)=E(X)E(Y)​。 对于任意两个变量X,Y​X, Y​X,Y​，常数a,b​a, b​a,b​，则E(aX+bY)=aE(X)+bE(Y)​E(aX + bY) = aE(X) + bE(Y)​E(aX+bY)=aE(X)+bE(Y)​。 逻辑数学 反演定理： 对于一个逻辑式YYY，若将其中所有的∧\\land∧，∨\\lor∨都对换（指的是变成相对的那个），000，111都对换，变量都取反（如果原来已经取反了那就变回原变量），则新的逻辑式是YYY的非，即Y‾\\overline YY。（注意，不属于单个变量的取反符号不变） 网络流及二分图 霍尔定理(Hall Theorem)： 假设二分图G={X,Y}​G = \\{X, Y\\}​G={X,Y}​存在完美匹配，等价于取任意正整数1≤k≤∣X∣​1 \\leq k \\leq |X|​1≤k≤∣X∣​，均满足我从X​X​X​集合选出k​k​k​个不同的点，那么它们总的连向的Y​Y​Y​集合的不同点个数不小于k​k​k​。 推广： 有二分图G={X,Y}​G = \\{X, Y\\}​G={X,Y}​，若X′⊆X​X&#x27; \\subseteq X​X′⊆X​中的点在Y​Y​Y​中可以被全部匹配，当且仅当对于X′​X&#x27;​X′​的任意子集S​S​S​，满足S​S​S​在Y​Y​Y​中的相邻顶点组成的点集T​T​T​有∣T∣≥∣S∣​|T| \\ge |S|​∣T∣≥∣S∣​。 图特定理(Tutte Theorem)： 在二分图G={X,Y}​G = \\{X, Y\\}​G={X,Y}​中，只要X′⊆X​X&#x27; \\subseteq X​X′⊆X​可以被某个匹配盖住,Y′⊆Y​Y&#x27; \\subseteq Y​Y′⊆Y​也可以被某个匹配盖住（不需要是同一个匹配），那么X′∪Y′​X&#x27; \\cup Y&#x27;​X′∪Y′​也可以被某个匹配盖住。 博弈 SG函数： SGX=MEX({SGY∣(X,Y)∈E})SG_X = MEX(\\{SG_Y | (X, Y) \\in E\\}) SGX​=MEX({SGY​∣(X,Y)∈E}) 其中，E​E​E​是转移集合，(X,Y)​(X, Y)​(X,Y)​是一个转移。 SG定理： 若SGXSG_XSGX​为0，则XXX是一个必败态。（要满足整个游戏不存在平局态） 证明用归纳。 exSG定理： 设一个游戏间的运算+++，X+YX+YX+Y表示将两个游戏复合，即这两个游戏不互相影响，但在同一个游戏X+YX+YX+Y中。 设游戏X=X1+X2+…+Xn​X = X_1 + X_2 + \\ldots + X_n​X=X1​+X2​+…+Xn​​，则SGX=SGX1⊕SGX2⊕…⊕SGXn​SG_X = SG_{X_1} \\oplus SG_{X_2} \\oplus \\ldots \\oplus SG_{X_n}​SGX​=SGX1​​⊕SGX2​​⊕…⊕SGXn​​​。 其证明就是要证明这类游戏的SG函数的两个性质： 1.∀a∈N,a&lt;b,∃X′∈FX,SGX′=a​\\forall a \\in N, a &lt; b, \\exists X&#x27; \\in F_X, SG_{X&#x27;} = a ​∀a∈N,a&lt;b,∃X′∈FX​,SGX′​=a​； 2.∀X′∈FX,SGX′≠b​\\forall X&#x27; \\in F_X, SG_{X&#x27;} \\neq b​∀X′∈FX​,SGX′​​=b​。 其中X′​X&#x27;​X′​是游戏X​X​X​的一个转移，FX​F_X​FX​​是游戏X​X​X​的转移集合。 证明一个归纳，一个反证。 纳什均衡： 一个重要的约束：双方的选择都是独立的，即不受对方选择的影响。 进行博弈的双方因为站在“对抗”的角度而非“合作”的角度上进行游戏，双方都想最大化子自己的收益/最小化对方的收益，且由于双方选择不受对方影响，在双方都不知道对方决策的情况下，一定会调整自己选择的概率使得自己的期望收益在对手采取不同策略的情况下达到平衡。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://WHchuan123.github.io/tags/笔记/"},{"name":"定理","slug":"定理","permalink":"http://WHchuan123.github.io/tags/定理/"}]},{"title":"共勉","date":"2019-03-17T00:40:55.619Z","path":"2019/03/17/共勉/","text":"曾经在某吧里面看到了一个远古帖子，许多湖北省的oier在对省队选拔中出现的偏差非常不满。不管孰错孰对，vfk在那里说的一段话令我惊叹。惊叹后是沉思。 节选如下： 我认为信息学竞赛考察的是信息学的思想，为了考察思想就得用一些手段。举一个简单的例子：XXXXXXXXXXXXXXXXXX，求最小值。假设这题方法是dp。这是纯信息题，认同吧。但是这样有缺点：既然是最小值嘛，有人可以绕开dp，用随机化之类的东西混分。 于是就有了：XXXXXXXXXXXXXXXXXX，求方案数。XXXXXXXXXXXXXXXXXX，求期望。我们假设还是能用类似的dp做。于是LZ可能就不服了：不公平！数学题！min有一个性质：min(a, b, c) = min(min(a, b), min(b, c))但是加法没有：a + b + c != (a + b) + (b + c)涉及到加法来把所有的解合并起来的东西，都要求你不重不漏，从而更有挑战性。并且避免了随机化骗分。 而且我觉得期望特别厉害，有一些min的性质：min(ka, kb) = kmin(a, b) =&gt; E(kX) = kE(X)min(a + x, a + y, b + x, b + y) = min(a, b) + min(x, y) =&gt; E(X + Y) = E(X) + E(Y)枚举最小答案判定是否有解 =&gt; EX = Pr(X &gt;= 0) + Pr(X &gt;= 1) + Pr(X &gt;= 2) + …所以期望有时候是绝佳的替代品。只要约定俗成假定各位OI选手都知道期望的性质。而事实上，我们高中课本上面还是提了几句的。（虽然讲得比较坑 = =……无力吐槽）如果你专注竞赛那么迟早会在做题中知道期望的性质，如果你专注文化课那么迟早会在数学课上遇见它。 所以我要是出题人，如果我想考dp，我肯定更愿意出方案数和期望，而不是最小值。这是真的是数学题吗？有时候看起来觉得显然是数学题的题目，只是信息学的包装。 再论实际用途。为什么快速排序的期望时间复杂度是O(n log n)而冒泡排序不是？为什么双旋splay的时间复杂度是均摊O(log n)而单旋的不是？为什么并查集的时间复杂度里有个某个阿克曼函数的反函数?为什么线段树的区间查询操作是O(log n)？我估计你没看过证明。不然就不会说出“只有复旦注重数学”。你说数据结构应该算纯信息学。那他的证明中可是货真价实的数学哦。我想问，难道那些发明这些科技的人是用一种“纯粹的算法能力”搞出这些东西，然后再马马虎虎糊弄一下数学证明的吗？显然不是。物理学中有一句令人印象深刻的道理：无论是什么奇谈怪论，只要他能用实验证明是对的，我们就接受他。实验是检验真理的唯一标准。你看，相对论那么颠覆性的东西现在也被人接受了。同样我们也可以说：既然数学给计算机带来了科技，带来了效率上的提升，那好，我们就可以认定数学是信息学思想的一部分。信息学需要数学，但不是纯数学里的数学，也不是物理里的数学。我认为基本上各个领域都需要数学作为支撑，只是用的方面不同。而我认为，信息学竞赛并不是在培养只会写代码的码农。是的，代码能力很重要，但并不只是这些。还是在培养的是能用信息学的思想去创造新的科技的计算机大师。 其实我曾经也一度对OI题中混入数学题感到愤怒。但是静下心来多接触一下我明白了其实并不是在考数学，那个东西就是信息学。 不知道你有没有知道昨天的题解。如果没有建议先去看看吧。仔细想想，于是你会明白没有人在用数学坑OIer。 （说句题外话，现役中小部分比如pyx、以及dzy loves math之流除外。你们都太神了 T_T） 不过我觉得质疑没有数据结构是对的啊。我赞同。但是我想说第三题的部分分里有树状数组。粗略点理解数据结构为何物，第二题的dp中用到了前缀和。（至少我用了……T_T）当然第一试没有出数据结构不代表第二试不会出。如果两试都出现了真数据结构题，那么我觉得是否太频繁了这个值得探讨。其实我觉得有时候数据结构题没出好就变成了裸题，OI赛场变成了打字比赛，AC者众。而且数据结构题的解集多半是多项式级的，而最优化问题、方案数、期望之类多半都是指数级的解集，从而更好出数据卡暴力。综上出题人觉得宁可不出数据结构。 这是我个人对于信息学的见解 = =……求轻喷。我真心希望湖北能出几位计算机大师而不是“为进省队头破血流者”。所以我才会说这么多…… 在这以前，只知道vfk是OI界的master，但是也仅仅是master罢了。 但是看了这段话，我才明白，oier刚开始学OI的目的是不太一样的，但是慢慢地，到了高中以后，竞赛性质凸显，功利化也在所难免。也许我们正在慢慢失去初心…… 初心难守是事实，但是也许就像vfk这样，越是厉害的人，越能懂得OI的意义所在。 对我而言，OI不仅仅是竞赛。OI还是生活。有时我会庆幸我当初没有去其他竞赛。或许我去搞数竞也能混得很好。但是可能又是一个完全不一样的世界了。 换句话说，我对我的现状不说很满足，但是满意了。毕竟我还有梦可追。I&#39;am still young. 以此共勉。活得不必很精彩，但至少要有意义。","tags":[]},{"title":"websites","date":"2019-03-16T13:26:26.995Z","path":"2019/03/16/websites/","text":"这里是一些有用的网站们： latex&amp;markdown相关： latex数学公式汇总 latex语法总结 latex记号一览","tags":[{"name":"网站","slug":"网站","permalink":"http://WHchuan123.github.io/tags/网站/"}]}]