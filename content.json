[{"title":"多项式学习笔记","date":"2019-03-17T12:47:45.148Z","path":"2019/03/17/多项式学习笔记/","text":"序 FFT什么的我到现在基本什么记不得，最明智的当然是被板子。当然这对学FWT可能有点困难……（至少现在还不会） 但相比之下，多项式操作就清真多了。（多点求值，快速差值除外） 以下是多项式的一些操作与总结。 还有就是，下面的东西其实都是用ntt写的。。。 多项式乘法（卷积） 不讲。 复杂度：T(n)=O(nlog⁡n)​T(n) = O(n \\log n)​T(n)=O(nlogn)​。 多项式模x的m次 这是一个需要注意的地方。是个很重要的初始化。 把一个nnn次多项式放到模xmx ^ mxm的意义下去。 复杂度：O(n)​O(n)​O(n)​。 多项式求逆 已知n−1n-1n−1次多项式A(x)A(x)A(x)，求n−1n-1n−1次多项式B(x)B(x)B(x)，即A(x)A(x)A(x)在模xnx^nxn意义下的逆。 设A(x)−1≡B(x)(xn)​A(x) ^ {-1} \\equiv B(x) (x ^ n)​A(x)−1≡B(x)(xn)​。考虑递归到xn/2​x ^ { n / 2}​xn/2​去做。（为了方便，可以在初始将n都变成2的幂次） 注意，这里包括下面的，以这种递归方法做的运算都是为了求出一个mod xn​x^n​xn​意义下的多项式，满足上式；也就是说，在n次及更高项，系数都是0。 假设我们已经知道了A(x)−1≡B0(x)(xn/2)​A(x) ^ {-1} \\equiv B_0(x) (x ^ {n / 2})​A(x)−1≡B0​(x)(xn/2)​，则必然B(x)≡B0(x)(xn/2)​B(x) \\equiv B_0(x) (x ^ {n / 2})​B(x)≡B0​(x)(xn/2)​。 则： B(x)−B0(x)≡0(xn/2)(B(x)−B0(x))2≡0(xn)B(x)2−2B(x)B0(x)+B0(x)2≡0(xn)B(x)A(x)−2B0(x)A(x)+B0(x)2≡0(xn)B(x)≡2B0(x)−A(x)B0(x)2(xn)\\begin{aligned} &amp; B(x) - B_0(x) \\equiv 0 (x ^ {n / 2}) \\\\ &amp; (B(x) - B_0(x)) ^ 2 \\equiv 0 (x ^ {n}) \\\\ &amp; B(x) ^ 2 - 2B(x)B_0(x) + B_0(x) ^ 2 \\equiv 0 (x ^ {n}) \\\\ &amp; \\frac {B(x)}{A(x)} - \\frac {2B_0(x)}{A(x)} + B_0(x) ^ 2 \\equiv 0 (x ^ n) \\\\ &amp; B(x) \\equiv 2B_0(x) - A(x)B_0(x) ^ 2 (x ^ n) \\\\ \\end{aligned} ​B(x)−B0​(x)≡0(xn/2)(B(x)−B0​(x))2≡0(xn)B(x)2−2B(x)B0​(x)+B0​(x)2≡0(xn)A(x)B(x)​−A(x)2B0​(x)​+B0​(x)2≡0(xn)B(x)≡2B0​(x)−A(x)B0​(x)2(xn)​ 每次递归中调用2次dft，1次idft， 复杂度：T(n)=T(n2)+O(nlog⁡n)⇒T(n)=O(nlog⁡n)​T(n) = T( \\frac {n}{2}) + O(n \\log n) \\Rightarrow T(n) = O(n \\log n)​T(n)=T(2n​)+O(nlogn)⇒T(n)=O(nlogn)​ 多项式开根 已知n−1n-1n−1次多项式A(x)A(x)A(x)，求n−1n-1n−1次多项式B(x)B(x)B(x)，即A(x)A(x)A(x)在模xnx^nxn意义下的平方根（保证有解）。 设A(x)1/2≡B(x)(xn)​A(x) ^ {1/2} \\equiv B(x) (x ^ n)​A(x)1/2≡B(x)(xn)​。仍考虑递归到xn/2​x ^ { n / 2}​xn/2​去做。 假设我们已经知道了A(x)1/2≡B0(x)(xn/2)​A(x) ^ {1/2} \\equiv B_0(x) (x ^ {n / 2})​A(x)1/2≡B0​(x)(xn/2)​，则必然B(x)≡B0(x)(xn/2)​B(x) \\equiv B_0(x) (x ^ {n / 2})​B(x)≡B0​(x)(xn/2)​。同样也有A(x)≡B(x)2≡B0(x)2(xn/2)​A(x) \\equiv B(x) ^ 2 \\equiv B_0(x) ^ 2 (x ^ {n / 2})​A(x)≡B(x)2≡B0​(x)2(xn/2)​ 则： B(x)2−B0(x)2≡0(xn/2)(B(x)2−B0(x)2)2≡0(xn)B(x)4−2B(x)2B0(x)2+B0(x)2≡0(xn)B(x)4+2B(x)2B0(x)2+B0(x)2≡4B(x)2B0(x)2(xn)B(x)2+B0(x)2≡2B(x)B0(x)(xn)A(x)+B0(x)2≡2B(x)B0(x)(xn)B(x)≡A(x)+B0(x)22B0(x)(xn)\\begin{aligned} &amp; B(x) ^ 2 - B_0(x) ^ 2 \\equiv 0 (x ^ {n / 2}) \\\\ &amp; (B(x) ^ 2 - B_0(x) ^ 2) ^ 2 \\equiv 0 (x ^ {n}) \\\\ &amp; B(x) ^ 4 - 2B(x) ^ 2 B_0(x) ^ 2 + B_0(x) ^ 2 \\equiv 0 (x ^ {n}) \\\\ &amp; B(x) ^ 4 + 2B(x) ^ 2 B_0(x) ^ 2 + B_0(x) ^ 2 \\equiv 4B(x) ^ 2 B_0(x) ^ 2 (x ^ {n}) \\\\ &amp; B(x) ^ 2 + B_0(x) ^ 2 \\equiv 2B(x)B_0(x) (x ^ {n}) \\\\ &amp; A(x) + B_0(x) ^ 2 \\equiv 2B(x)B_0(x) (x ^ n) \\\\ &amp; B(x) \\equiv \\frac {A(x) + B_0(x)^2}{2B_0(x)} (x ^ n) \\\\ \\end{aligned} ​B(x)2−B0​(x)2≡0(xn/2)(B(x)2−B0​(x)2)2≡0(xn)B(x)4−2B(x)2B0​(x)2+B0​(x)2≡0(xn)B(x)4+2B(x)2B0​(x)2+B0​(x)2≡4B(x)2B0​(x)2(xn)B(x)2+B0​(x)2≡2B(x)B0​(x)(xn)A(x)+B0​(x)2≡2B(x)B0​(x)(xn)B(x)≡2B0​(x)A(x)+B0​(x)2​(xn)​ 注意上面有一个开方的步骤。这个步骤事实上开过方后，还是在mod xnx ^ nxn意义下成立的。 每次递归中调用1次求逆，2次dft，1次idft。 复杂度：T(n)=T(n2)+O(nlog⁡n)⇒T(n)=O(nlog⁡n)​T(n) = T( \\frac {n}{2}) + O(n \\log n) \\Rightarrow T(n) = O(n \\log n)​T(n)=T(2n​)+O(nlogn)⇒T(n)=O(nlogn)​ 多项式求导（微分） 很简单，不讲…… 但是要说一下，实现上尽管是个求导的过程，而在推式子时不出现导数，只出现微分。 要注意在mod几次的意义下求的导，是先mod再导还是先导再mod，很重要。 复杂度：T(n)=O(n)​T(n) = O(n)​T(n)=O(n)​。 多项式积分 不讲。就是注意常数项。 复杂度：T(n)=O(n)T(n) = O(n)T(n)=O(n)。 多项式求ln 已知n−1n-1n−1次多项式A(x)A(x)A(x)，求n−1n-1n−1次多项式B(x)B(x)B(x)，即A(x)A(x)A(x)在模xnx^nxn意义下的ln（保证有解）。（我也不知道ln一个多项式是什么。可能可以参考泰勒展开式……） 设ln⁡(A(x))≡B(x)(xn)​\\ln(A(x)) \\equiv B(x) (x ^ n)​ln(A(x))≡B(x)(xn)​。递归到xn/2​x ^ { n / 2}​xn/2​去做可以不用。 d(ln⁡(A(x))dx≡d(B(x))dx(xn)d(A(x))A(x)dx≡d(B(x))dx(xn)∫d(A(x))A(x)dxdx≡∫d(B(x))dxdx(xn)∫d(A(x))dxA(x)−1dx≡B(x)(xn)\\begin{aligned} &amp; \\frac {d(\\ln(A(x))}{dx} \\equiv \\frac {d(B(x))}{dx} (x ^ {n}) \\\\ &amp; \\frac {d(A(x))}{A(x)dx} \\equiv \\frac {d(B(x))}{dx} (x ^ {n}) \\\\ &amp; \\int \\frac {d(A(x))}{A(x)dx} dx \\equiv \\int \\frac {d(B(x))}{dx} dx (x ^ {n}) \\\\ &amp; \\int \\frac {d(A(x))}{dx} A(x) ^ {-1} dx \\equiv B(x) (x ^ {n}) \\\\ \\end{aligned} ​dxd(ln(A(x))​≡dxd(B(x))​(xn)A(x)dxd(A(x))​≡dxd(B(x))​(xn)∫A(x)dxd(A(x))​dx≡∫dxd(B(x))​dx(xn)∫dxd(A(x))​A(x)−1dx≡B(x)(xn)​ 最后一个式子告诉我们，把A(x)A(x)A(x)的逆与A(x)A(x)A(x)的导函数卷起来后积个分即可。 只要调用1次求导，1次求逆，1次卷积，1次积分即可。 复杂度：T(n)=O(nlog⁡n)T(n) = O(n \\log n)T(n)=O(nlogn)。 多项式泰勒展开 介绍exp之前的必经之路。 首先正常的泰勒展开： f(x)=∑i=0∞f(i)(x0)i!(x−x0)if(x) = \\sum_{i = 0} ^ \\infin \\frac {f^{(i)}(x_0)}{i!}(x - x_0) ^ i f(x)=i=0∑∞​i!f(i)(x0​)​(x−x0​)i 设g∘f(x)≡0​g \\circ f(x) \\equiv 0​g∘f(x)≡0​，考虑在f0(x)​f_0(x)​f0​(x)​处展开，则： g∘f(x)≡g∘f0(x)+d(g∘f0(x))d(f0(x))(f(x)−f0(x))+d(d(g∘f0(x)))(d(f0(x)))2(f(x)−f0(x))2+...\\begin{aligned} &amp; g \\circ f(x) \\equiv g \\circ f_0(x) + \\frac {d(g \\circ f_0(x))}{d(f_0(x))} (f(x) - f_0(x)) + \\frac {d(d(g \\circ f_0(x)))}{(d(f_0(x))) ^ 2} (f(x) - f_0(x)) ^ 2 + ... \\end{aligned} ​g∘f(x)≡g∘f0​(x)+d(f0​(x))d(g∘f0​(x))​(f(x)−f0​(x))+(d(f0​(x)))2d(d(g∘f0​(x)))​(f(x)−f0​(x))2+...​ （用微分写起来有点烦……） 多项式求exp 已知n−1​n-1​n−1​次多项式A(x)​A(x)​A(x)​，求n−1​n-1​n−1​次多项式B(x)​B(x)​B(x)​，即A(x)​A(x)​A(x)​在模xn​x^n​xn​意义下的exp（保证有解）。 设exp⁡(A(x))≡B(x)(xn)​\\exp(A(x)) \\equiv B(x) (x ^ n)​exp(A(x))≡B(x)(xn)​。又要递归到xn/2​x ^ { n / 2}​xn/2​去做了。 即我们知道了exp⁡(A(x))≡B0(x)(xn/2)​\\exp(A(x)) \\equiv B_0(x) (x ^ {n / 2})​exp(A(x))≡B0​(x)(xn/2)​。 ln⁡(B(x))≡A(x)(xn)ln⁡(B0(x))+d(ln⁡(B0(x)))d(B0(x))(B(x)−B0(x))+d(d(ln⁡(B0(x))))(d(B0(x)))2(B(x)−B0(x))2+...≡A(x)(xn)ln⁡(B0(x))+1B0(x)(B(x)−B0(x))+0+0+...≡A(x)(xn)ln⁡(B0(x))+B(x)B0(x)−1≡A(x)(xn)B(x)≡B0(x)(A(x)+1−ln⁡(B0(x)))(xn)\\begin{aligned} &amp; \\ln(B(x)) \\equiv A(x) (x ^ {n}) \\\\ &amp; \\ln(B_0(x)) + \\frac {d(\\ln(B_0(x)))}{d(B_0(x))}(B(x) - B_0(x)) + \\frac {d(d(\\ln(B_0(x))))}{(d(B_0(x))) ^ 2}(B(x) - B_0(x)) ^ 2 + ... \\equiv A(x) (x ^ {n}) \\\\ &amp; \\ln(B_0(x)) + \\frac {1}{B_0(x)}(B(x) - B_0(x)) + 0 + 0 + ... \\equiv A(x) (x ^ {n}) \\\\ &amp; \\ln(B_0(x)) + \\frac {B(x)}{B_0(x)} - 1 \\equiv A(x) (x ^ n) \\\\ &amp; B(x) \\equiv B_0(x)(A(x) + 1 - \\ln(B_0(x))) (x ^ n) \\end{aligned} ​ln(B(x))≡A(x)(xn)ln(B0​(x))+d(B0​(x))d(ln(B0​(x)))​(B(x)−B0​(x))+(d(B0​(x)))2d(d(ln(B0​(x))))​(B(x)−B0​(x))2+...≡A(x)(xn)ln(B0​(x))+B0​(x)1​(B(x)−B0​(x))+0+0+...≡A(x)(xn)ln(B0​(x))+B0​(x)B(x)​−1≡A(x)(xn)B(x)≡B0​(x)(A(x)+1−ln(B0​(x)))(xn)​ 上面第二步我们选择在B0(x)​B_0(x)​B0​(x)​处展开。 第三步中为什么第2项（从第0项开始）后面就都是0了呢？ 注意到B(x)≡B0(x)(xn/2)B(x) \\equiv B_0(x)(x ^ {n / 2})B(x)≡B0​(x)(xn/2)，即B(x)−B0(x)≡0(xn/2)B(x) - B_0(x) \\equiv 0(x ^ {n / 2})B(x)−B0​(x)≡0(xn/2)，说明C(x)=B(x)−B0(x)C(x) = B(x) - B_0(x)C(x)=B(x)−B0​(x)的最低非零次是至少为n/2n / 2n/2次的，那么C(x)2C(x) ^ 2C(x)2也就是(B(x)−B0(x))2(B(x) - B_0(x)) ^ 2(B(x)−B0​(x))2的最低非零次是至少为n/2+n/2=nn / 2 + n / 2 = nn/2+n/2=n次的。然而我们要求的是mod xnx ^ nxn意义下的，也就是说它在这个意义下相当于000多项式。那么就可以不计算了。后面第3项、第4项等更不用说了。 每次递归调用1次求ln，2次dft，1次idft。 复杂度：T(n)=T(n2)+O(nlog⁡n)⇒T(n)=O(nlog⁡n)​T(n) = T( \\frac {n}{2}) + O(n \\log n) \\Rightarrow T(n) = O(n \\log n)​T(n)=T(2n​)+O(nlogn)⇒T(n)=O(nlogn)​。 多项式快速幂 神奇的方法。 要用到公式ekln⁡x=xk​e ^ {k\\ln x} = x ^ k​eklnx=xk​。 已知n−1​n-1​n−1​次多项式A(x)​A(x)​A(x)​，和正整数k​k​k​，求n−1​n-1​n−1​次多项式B(x)​B(x)​B(x)​，即A(x)​A(x)​A(x)​的k​k​k​次方在模xn​x^n​xn​意义下的多项式（保证有解）。 设A(x)k≡B(x)(xn)​A(x) ^ k \\equiv B(x) (x ^ n)​A(x)k≡B(x)(xn)​。 exp⁡(kln⁡(A(x))≡B(x)(xn)\\begin{aligned} &amp; \\exp(k \\ln(A(x)) \\equiv B(x) (x ^ n) \\\\ \\end{aligned} ​exp(kln(A(x))≡B(x)(xn)​ 简单一步。先求ln，再把每一项乘k，再exp回去。 但是要注意，求ln的话要保证A(x)A(x)A(x)的常数项为1。 这个怎么处理？ 设最低位非0项为p​p​p​，则可以先计算(A(x)apxp)k​(\\frac {A(x)}{a_p x^p}) ^ k​(ap​xpA(x)​)k​，再乘上apkxpk​a_p^k x ^ {pk}​apk​xpk​即可。 复杂度：T(n)=O(nlog⁡n)​T(n) = O(n \\log n)​T(n)=O(nlogn)​。 多项式翻转 作用是在翻转最高项和最低项的系数，次高项和次低项的系数，以此类推…… 记号为fR(x)​f ^ R (x)​fR(x)​。值得注意的是，对于n−1​n - 1​n−1​次多项式f(x)​f(x)​f(x)​，fR(x)=f(1x)xn−1​f^R(x) = f(\\frac {1}{x}) x ^ {n - 1}​fR(x)=f(x1​)xn−1​。 要注意先mod还是先翻转。 复杂度：T(n)=O(n)​T(n) = O(n)​T(n)=O(n)​。 多项式带余除法 已知n−1​n-1​n−1​次多项式A(x)​A(x)​A(x)​和m−1​m - 1​m−1​次多项式B(x)​B(x)​B(x)​（n≥m​n \\ge m​n≥m​），求n−m​n- m​n−m​次多项式q(x)​q(x)​q(x)​和m−2​m - 2​m−2​次多项式r(x)​r(x)​r(x)​，满足A(x)=B(x)q(x)+r(x)​A(x) = B(x)q(x) + r(x)​A(x)=B(x)q(x)+r(x)​。 由于显然有A(1x)=B(1x)q(1x)+r(1x)​A(\\frac {1}{x}) = B(\\frac {1}{x})q(\\frac {1}{x}) + r(\\frac {1}{x})​A(x1​)=B(x1​)q(x1​)+r(x1​)​，则AR(x)x−(n−1)=BR(x)x−(m−1)qR(x)x−(n−m)+rR(x)x−(m−2)​A^R(x) x ^ {-(n - 1)} = B ^ R(x) x ^ {-(m - 1)} q ^ R(x) x ^ {-(n - m)} + r ^ R(x) x ^ {-(m - 2)}​AR(x)x−(n−1)=BR(x)x−(m−1)qR(x)x−(n−m)+rR(x)x−(m−2)​。 两边同乘xn−1​x ^ {n - 1}​xn−1​，得到AR(x)=BR(x)qR(x)+rR(x)xn−m+1​A ^ R(x) = B ^ R(x) q ^ R(x) + r ^ R(x) x ^ {n - m + 1}​AR(x)=BR(x)qR(x)+rR(x)xn−m+1​ 考虑放在modxn−m+1​x ^ {n - m + 1}​xn−m+1​意义下做，此时qR​q ^ R​qR​和原来的没有区别，因为次数是n−m​n - m​n−m​次的。那么有 AR=BRqR(xn−m+1)​A ^ R = B ^ R q ^ R (x ^ {n - m + 1})​AR=BRqR(xn−m+1)​ 这个式子告诉我们，算出qR​q ^ R​qR​只要出BR(AR)−1​B ^ R (A ^ R) ^ {-1}​BR(AR)−1​在模xn−m+1​x ^ {n - m + 1}​xn−m+1​意义下的多项式即可。那么r=A−Bq​r = A - Bq​r=A−Bq​也就出来了。 整个过程调用3次翻转，1次求逆，2次卷积。 复杂度：T(n)=O(nlog⁡n)​T(n) = O(n \\log n)​T(n)=O(nlogn)​。 多项式gcd 简单说一说。 其实很简单。因为在FPF_{\\mathbb P}FP​上的多项式也组成了一个多项式环。并且这个环还是欧几里得整环，因此就可以做gcd啦。过程和整数的gcd是一样的。 最后还是最好把求出的gcd化成首一多项式。还是看要求咯。 最坏情况下每递归一次最多能把多项式降1次。 而每次递归要调用1次带余除法。 复杂度：T(n)=T(n−1)+O(nlog⁡n)⇒T(n)=O(n2log⁡n)​T(n) = T(n - 1) + O(n \\log n) \\Rightarrow T(n) = O(n ^ 2 \\log n)​T(n)=T(n−1)+O(nlogn)⇒T(n)=O(n2logn)​。 多项式求逆-EX 这里的求逆指的是在模任意多项式意义下的（可能无逆）。 即给出多项式A(x)A(x)A(x)，M(x)M(x)M(x)，求A(x)A(x)A(x)在模意义下M(x)M(x)M(x)的逆元A(x)−1A(x) ^ {-1}A(x)−1。 可以转为求A(x)P(x)+M(x)Q(x)=1​A(x) P(x) + M(x)Q(x) = 1​A(x)P(x)+M(x)Q(x)=1​的解。使用扩欧求解。 同样可以求A(x)P(x)+M(x)Q(x)=gcd⁡(A(x),M(x))​A(x) P(x) + M(x)Q(x) = \\gcd(A(x), M(x))​A(x)P(x)+M(x)Q(x)=gcd(A(x),M(x))​。 分治FFT 适用于已知g​g​g​和f0​f_0​f0​​， 求解fi=∑j=1ifi−jgj​f_i = \\sum_{j = 1} ^ i f_{i - j}g_j​fi​=∑j=1i​fi−j​gj​​的问题。 都说了是分治，给你一个fft模板，都会做吧。 复杂度：T(n)=2T(n2)+O(nlog⁡n)⇒T(n)=O(nlog⁡2n)​T(n) = 2T(\\frac {n}{2}) + O(n \\log n) \\Rightarrow T(n) = O(n \\log ^2 n)​T(n)=2T(2n​)+O(nlogn)⇒T(n)=O(nlog2n)​。 看起来不是非常优秀啊。。。据说用求逆可以做到一只log？ 多项式优化线性递推 优化计算fn=∑i=1kcifn−i​f_n = \\sum_{i = 1} ^ k c_if_{n - i}​fn​=∑i=1k​ci​fn−i​​。 众所周知，矩阵快速幂是O(k3log⁡n)​O(k ^ 3 \\log n)​O(k3logn)​的。可以用转移矩阵的特征多项式优化。 矩阵AAA的特征多项式为f(λ)=det⁡(A−λI)f(\\lambda) = \\det (A - \\lambda I)f(λ)=det(A−λI)。（f(λ)=0f(\\lambda) = 0f(λ)=0解得的λ\\lambdaλ即为矩阵的特征值） 一个结论： 对于线性递推fn=∑i=1kcifn−if_n = \\sum_{i = 1} ^ k c_if_{n - i}fn​=∑i=1k​ci​fn−i​ ，它的转移矩阵的特征多项式是Ak=∑i=1kciAk−iA ^ k = \\sum_{i = 1} ^ k c_i A ^ {k - i}Ak=∑i=1k​ci​Ak−i。 考虑我们要求的是An​A ^ n​An​。这可以被表示为Ai(1≤i≤k)​A ^ i (1 \\le i \\le k)​Ai(1≤i≤k)​的线性组合。 假如我们知道An=∑i=0k−1piAiA ^ n = \\sum_{i = 0} ^ {k - 1} p_iA ^ iAn=∑i=0k−1​pi​Ai，Am=∑i=0k−1qiAi​A ^ m = \\sum_{i = 0} ^ {k - 1} q_iA ^ i​Am=∑i=0k−1​qi​Ai​，则有 An+m=AnAm=∑i=02k−2∑j=0ipjqi−jAi\\begin{aligned} A ^ {n + m} &amp; = A ^ n A ^ m \\\\ &amp; = \\sum_{i = 0} ^ {2k - 2} \\sum_{j = 0} ^ i p_j q_{i - j} A ^ i \\end{aligned} An+m​=AnAm=i=0∑2k−2​j=0∑i​pj​qi−j​Ai​ 这显然是一个2k−22k - 22k−2次的多项式，可以直接暴力降次降到k−1k - 1k−1次。 然后我们发现计算AnA ^ nAn可以用快速幂分治（即倍增）计算。 如果上面的求和与降次都直接暴力算，复杂度就是O(k2log⁡n)O(k ^ 2 \\log n)O(k2logn)的。 如果要优化，可以用FFT来代替暴力进行多项式乘法，复杂度O(klog⁡k)​O(k \\log k)​O(klogk)​；用多项式取模来代替暴力降次，复杂度 O(klog⁡k)​O(k \\log k)​O(klogk)​ 。于是一次倍增总复杂度为O(klog⁡⁡k)​O(k \\log ⁡k)​O(klog⁡k)​ 。加上快速幂，总复杂度为O(klog⁡klog⁡n)​O(k \\log k \\log n)​O(klogklogn)​。 当然，我们不会直接记矩阵AxA ^ xAx ，我们只需要记Ax=∑i=0k−1piAiA ^ x = \\sum_{i = 0} ^ {k - 1}p_i A ^ iAx=∑i=0k−1​pi​Ai 中的{p0,p1,…,pk−1}\\lbrace p_0, p_1, \\ldots, p_{k - 1} \\rbrace{p0​,p1​,…,pk−1​} 就可以了。 并且还有一个小优化，就是直接计算AnA ^ nAn即可（即快速幂倍增时以nnn为指数），然后答案fn=∑i=0k−1pifif_n = \\sum_{i = 0} ^ {k - 1} p_i f_ifn​=∑i=0k−1​pi​fi​（ppp为倍增得出的向量）。 这个优化的正确性： 如果设初始向量为B0B_0B0​，Bn=AnB0(n≥1)B_n = A ^ n B_0(n \\ge 1)Bn​=AnB0​(n≥1)，则有 Bi=[f(i)f(i+1)…f(i+k−1)]B_i = \\begin{bmatrix} f(i) \\\\ f(i + 1) \\\\ \\ldots \\\\ f(i + k - 1) \\end{bmatrix} Bi​=⎣⎢⎢⎡​f(i)f(i+1)…f(i+k−1)​⎦⎥⎥⎤​ 又 Bn=∑i=0k−1piBi=∑i=0k−1pi[f(i)f(i+1)…f(i+k−1)]=[∑i=0k−1pif(i)∑i=0k−1pif(i+1)…∑i=0k−1pif(i+k−1)]\\begin{aligned} B_n &amp; = \\sum_{i = 0} ^ {k - 1} p_i B_i \\\\ &amp; = \\sum_{i = 0} ^ {k - 1} p_i \\begin{bmatrix} f(i) \\\\ f(i + 1) \\\\ \\ldots \\\\ f(i + k - 1) \\end{bmatrix} \\\\ &amp; = \\begin{bmatrix} \\sum_{i = 0} ^ {k - 1} p_i f(i) \\\\ \\sum_{i = 0} ^ {k - 1} p_i f(i + 1) \\\\ \\ldots \\\\ \\sum_{i = 0} ^ {k - 1} p_i f(i + k - 1) \\end{bmatrix} \\\\ \\end{aligned} Bn​​=i=0∑k−1​pi​Bi​=i=0∑k−1​pi​⎣⎢⎢⎡​f(i)f(i+1)…f(i+k−1)​⎦⎥⎥⎤​=⎣⎢⎢⎡​∑i=0k−1​pi​f(i)∑i=0k−1​pi​f(i+1)…∑i=0k−1​pi​f(i+k−1)​⎦⎥⎥⎤​​ 然后我们发现我们求的是BnB_nBn​的第一项，即∑i=0k−1pif(i)\\sum_{i = 0} ^ {k - 1} p_i f(i)∑i=0k−1​pi​f(i)。 另附一个小姿势 注意点 我认为这部分是最重要的！ 开门见山吧。 写fft/ntt的时候一般不预处理单位根的幂次。因为这个处理比较慢，而且如果有多项式一些笔记麻烦的运算的话，调用卷积的次数一多，那预处理的次数也就越多。所以宁可在fft/ntt的时候每次直接处理。 fft/ntt的主要运算不要写if，尽量写得优美一点，可能会手动循环展开（我也不是很清楚，但是这样真的不会慢） 做任何东西前，都要把长度处理乘2的幂次！这样可以很方便！ 在调用的数组中，不要把当前不在处理范围内的位置修改，如果有修改，应该及时发现，调用modx函数（即把不在处理范围的高位都清空）。如果现在处理的是[0, n - 1]，建议把[n, 2n - 1]都清空。（可能是我写的模板过多地设计数组调用，以非常容易出错） 调试的时候debug()函数极其有用！ 写较复杂的递归函数，在子程序内开static的数组会比较快，但是不要贪图小便宜，数组最好专设专用，比如在求gcd里面。 求导和积分函数注意n-1和0的位置。 递归调用数组尽量复制一份，尽量不要修改原来传进来的数组。 模板中写的n都是多项式的次数+1，注意了。 写fft的时候那个去实数变整数对于每一个dft过的多项式idft回来后都要把每一项+0.5再取整。 例题 Triple Sums - SPOJ TSUM Super Rooks on Chessboard - ACM ICPC World Finals 2013 Warmup 3-idiots - HDU 4609 Arithmetic Progressions - Codechef November Challenge 2012 Normal - BZOJ 3451 SumOfArrays - SRM 603, Level 3 Evaluation - HDU 4656 The Child and Binary Tree - CF Round #250 总结 fft/ntt其实不是重点，重点的还是生成函数部分的推导。这个部分要努力加强啊！！ 这种生成函数的题目有时可以加分治，有时可以加分块，有时可以加矩阵，有时可以用其他方法优化，有时还可以套上什么东西，比如……点分fft。有时候可能会有任意模数fft。 推公式有些套路：翻转下标，平移下标，构造函数，拆分函数等等等等。 另外，还要补充一些重要恒等式。 min{x,y}=∑i=1∞[x≥i][y≥i]min\\{x, y\\} = \\sum_{i = 1} ^ {\\infin} [x \\ge i][y \\ge i] min{x,y}=i=1∑∞​[x≥i][y≥i] xn‾=∑k=0nss1(n,k)xk（这里的ss1是有符号第一类斯特林数）x ^ {\\underline n} = \\sum_{k = 0} ^ n ss_1(n, k)x ^ k（这里的ss_1是有符号第一类斯特林数） xn​=k=0∑n​ss1​(n,k)xk（这里的ss1​是有符号第一类斯特林数） xn=∑k=0ns2(n,k)xk‾x ^ n = \\sum_{k = 0} ^ n s_2(n, k)x ^ {\\underline k} xn=k=0∑n​s2​(n,k)xk​ s1(n+1,m+1)=∑k=0ns1(n,k)(km)s_1(n + 1, m + 1) = \\sum_{k = 0} ^ n s_1(n, k) \\binom {k}{m} s1​(n+1,m+1)=k=0∑n​s1​(n,k)(mk​)","tags":[{"name":"笔记","slug":"笔记","permalink":"http://WHchuan123.github.io/tags/笔记/"},{"name":"多项式","slug":"多项式","permalink":"http://WHchuan123.github.io/tags/多项式/"}]},{"title":"算法总结","date":"2019-03-17T05:09:54.829Z","path":"2019/03/17/算法总结/","text":"数学 线性代数 矩阵乘法 一些有意思的东西（其实很naive）。 对于两个n×nn \\times nn×n的矩阵A,BA, BA,B，设C=ABC = ABC=AB考虑： 给AAA的最后加上一列1，BBB的最后加上一行1 ——等价于给CCC的每个元素+1； 给AAA的最后加上一行1，BBB的最后加上一列1 ——在Ci,n+1(1≤i≤n)​C_{i, n + 1}(1 \\le i \\le n)​Ci,n+1​(1≤i≤n)​存着A​A​A​的第i​i​i​行的和，在Cn+1,j(1≤j≤n)​C_{n + 1, j}(1 \\le j \\le n)​Cn+1,j​(1≤j≤n)​存着A​A​A​的第j​j​j​列的和。 尽管这在程序里并不是很需要，但是在手推式子的时候可以把上述操作用矩阵的语言表达。 拟阵 这是一个非常dark的东西。这里只介绍有限拟阵。 定义一个二元组M=(S,I)​M = (S, I)​M=(S,I)​满足： 1、SSS是一个有限集； 2、III是由SSS的一些子集组成的有限非空集合（即非空族），且III被称为SSS的独立子集； 3、∅∈I​\\emptyset \\in I​∅∈I​；（被称作独立集公理） 4、这个二元组具有遗传性：如果B∈I∧A⊆B​B \\in I \\land A \\subseteq B​B∈I∧A⊆B​，则有A∈I​A \\in I​A∈I​； 5、这个二元组具有交换性质：如果A∈I∧B∈I∧∣A∣&lt;∣B∣​A \\in I \\land B \\in I \\land |A| &lt; |B|​A∈I∧B∈I∧∣A∣&lt;∣B∣​，则∃x∈B−A​\\exist x \\in B - A​∃x∈B−A​使得A∪{x}∈I​A \\cup \\{x\\} \\in I​A∪{x}∈I​。（被称作独立扩充公理） 有一个非常形象的例子： 若M=(S,I)​M = (S, I)​M=(S,I)​是一个拟阵，其中： S={1,2,3},I={size≤2的子集}={∅,{1},{2},{3},{1,2},{1,3},{2,3}}S = \\lbrace 1, 2, 3\\rbrace, I = \\lbrace size \\leq 2的子集\\rbrace = \\lbrace \\emptyset, \\lbrace1\\rbrace, \\lbrace2\\rbrace, \\lbrace3\\rbrace, \\lbrace1, 2\\rbrace, \\lbrace1, 3\\rbrace, \\lbrace2, 3\\rbrace \\rbrace S={1,2,3},I={size≤2的子集}={∅,{1},{2},{3},{1,2},{1,3},{2,3}} 容易证明，这个系统是满足上述性质的，所以M=(S,I)​M = (S, I)​M=(S,I)​是拟阵这个命题为真。 有一个性质： 如果拟阵中的一个独立子集A​A​A​不存在扩展，那么就称它是极大的，且拟阵中所有极大的独立子集都具有相同大小（这个大小也称拟阵的秩）。这里的扩展的定义是指，将独立子集A​A​A​与这个扩展集合取并（有时扩展集合就是一个单一元素），新的集合依然是S​S​S​的独立子集。那么如果拟阵中的所有极大的独立子集不具有相同大小，那就可以用交换性质而推出大小较小者不是极大的结论，这显然是不对的。 再来讲一下一个关键的东西：加权拟阵。因为拟阵在OI里最大的用处是证明一些贪心，那么权值必然是需要的。 对于一个拟阵M=(S,I)​M = (S, I)​M=(S,I)​，如果用有一个权值函数w​w​w​关联了M​M​M​，并且对于S​S​S​中的每个元素x​x​x​都有w(x)&gt;0​w(x) &gt; 0​w(x)&gt;0​，则我们称这个拟阵是加权的。并且对于子集A​A​A​，其权值就是 w(A)=∑x∈Aw(x)w(A) = \\sum_{x \\in A}w(x) w(A)=x∈A∑​w(x) 考虑在贪心中使用拟阵。不妨考虑求的是最大权独立子集。 结论1：假定M=(S,I)​M = (S, I)​M=(S,I)​是一个加权拟阵，其加权函数为w​w​w​，且S​S​S​中所有元素已经按照权重从大到小排序了。令x​x​x​是S​S​S​中第一个满足{x}​\\{x\\}​{x}​独立的元素（如果存在），那么存在S​S​S​的一个最优独立子集A​A​A​包含x​x​x​。 证明？ 假设B​B​B​是任意非空的最优子集，且x∉B​x \\notin B​x∈/​B​。 对于任意y∈B​y \\in B​y∈B​，有w(y)≤w(x)​w(y) \\leq w(x)​w(y)≤w(x)​。 构造集合A={x}​A = \\{x\\}​A={x}​，根据独立扩充定理，可以反复地在B​B​B​中找出新元素加入A​A​A​直到∣A∣=∣B∣​|A| = |B|​∣A∣=∣B∣​，且保持A​A​A​是独立子集。 因此最后存在某个y∈B​y \\in B​y∈B​，使得A=(B−{y})∪{x}​A = (B - \\{y\\}) \\cup \\{x\\}​A=(B−{y})∪{x}​。 则有w(A)=w(B)−w(y)+w(x)≥w(B)​w(A) = w(B) - w(y) + w(x) \\ge w(B)​w(A)=w(B)−w(y)+w(x)≥w(B)​，命题得证。 结论2：若x​x​x​是我们在加权拟阵M=(S,I)​M = (S, I)​M=(S,I)​中第一个确定在最优解中的元素，则接下来的问题是寻找包含x​x​x​的一个最大权独立子集问题，可以归结于求加权拟阵M′=(S′,I′)​M&#x27;=(S&#x27;,I&#x27;)​M′=(S′,I′)​的一个最大权独立子集的问题。 其中S′={y∣ y∈S∧{x,y}∈I},I′={B∣B⊆S−{x}∧B∪{x}∈I}​S&#x27; = \\lbrace y | \\ y \\in S \\land \\lbrace x, y\\rbrace \\in I \\rbrace, I&#x27; = \\lbrace B | B \\subseteq S - \\lbrace x\\rbrace \\land B \\cup \\lbrace x\\rbrace \\in I\\rbrace​S′={y∣ y∈S∧{x,y}∈I},I′={B∣B⊆S−{x}∧B∪{x}∈I}​。 主要要证明两点： 1、在M′=(S′,I′)​M&#x27;= (S&#x27;, I&#x27;)​M′=(S′,I′)​中求得任意最优解X​X​X​均满足X∪{x}∈I​X \\cup \\{x\\} \\in I​X∪{x}∈I​； 2、在M=(S,I)​M = (S, I)​M=(S,I)​中包含x​x​x​的最优解X​X​X​一定可以表示为{x}∪X′​\\{x\\} \\cup X&#x27;​{x}∪X′​，其中X​X​X​是M′​M&#x27;​M′​的最优解。 这其实说明了拟阵优贪心最优子结构。 而实际是不会证明的 （其实这部分不会证明没关系） 至此我们就得出了一般的贪心算法了，很简单，就排个序，能取就去，不能取就不去，就没了。~~咕咕 应用： 最小生成树，最大权线性无关组…… 其实这些问题都有一个共性，就是关键的性质是有遗传性的，比如线性无关，比如不成环。 例如最小生成树问题： 已知N=(V,E)​N = (V, E)​N=(V,E)​，构造M=(S,I)​M = (S, I)​M=(S,I)​，其中S=E,I⊆2S​S = E, I \\subseteq 2 ^ S​S=E,I⊆2S​，且A∈I​A \\in I​A∈I​当且仅当A​A​A​构成的图是无环的。只需要证明M=(S,I)​M = (S, I)​M=(S,I)​是个拟阵即可。就满足最开始那几个性质和公理即可。 其实有限拟阵常见有很多，上面的线性基和最小生成树其实用到的分别是向量拟阵和图拟阵。其他还有组合拟阵，分割拟阵，环拟阵，匹配拟阵。 拟阵求交？求并？看了看不太会啊。 高代 对称差卷积FWT 即给定数组a,b​a, b​a,b​求 ck=∑i⊗j=kaibjc_k = \\sum_{i \\otimes j = k} a_i b_j ck​=i⊗j=k∑​ai​bj​ 这个东西和FFT一样建立在卷积定理的基础上。 做这个东西本质上是一个构造的方法。规定一些符号：(A,B)(A, B)(A,B)表示将数组A,BA, BA,B顺次连接组成的新数组。为了方便，假设a,b,ca,b,ca,b,c的长度都是2的幂次。 我们考虑分治递归着做，使得最后构造出的东西满足卷积定理： tf(f⊗g)=tf(f)×tf(g)tf(f \\otimes g) = tf(f) \\times tf(g) tf(f⊗g)=tf(f)×tf(g) 则可以这样： tf(f)=(tf(f0−f1),tf(f0+f1))tf(f) = (tf(f_0 - f_1), tf(f_0 + f_1)) tf(f)=(tf(f0​−f1​),tf(f0​+f1​)) 其中f0,f1​f_0, f_1​f0​,f1​​分别表示f​f​f​的前一半和后一半。而如果∣f∣=1​|f| = 1​∣f∣=1​，那么规定tf(f)=f​tf(f) = f​tf(f)=f​。 则可以证明构造出来的tf​tf​tf​变化是满足卷积定理的。 证明如下（用归纳）： tf(f⊗g)=tf((f0,f1)⊗(g0,g1))=tf(f0⊗g0+f1⊗g1,f0⊗g1+f1⊗g0)(由对称差卷积的定义得)=tf(f0⊗g0+f1⊗g1,f0⊗g1+f1⊗g0)=tf(f0⊗g0+f1⊗g1−f0⊗g1−f1⊗g0,f0⊗g0+f1⊗g1+f0⊗g1+f1⊗g0)=(tf((f0−f1)⊗(g0−g1)),tf((f0+f1)⊗(g0+g1)))=(tf(f0−f1)×tf(g0−g1),tf(f0+f1)×tf(g0+g1))=(tf(f0−f1),tf(f0+f1))×(tf(g0−g1)×tf(g0+g1))=tf(f)×tf(g)\\begin{aligned} tf(f \\otimes g) &amp; = tf((f_0, f_1) \\otimes (g_0, g_1)) \\\\ &amp; = tf(f_0 \\otimes g_0 + f_1 \\otimes g_1, f_0 \\otimes g_1 + f_1 \\otimes g_0) (由对称差卷积的定义得) \\\\ &amp; = tf(f_0 \\otimes g_0 + f_1 \\otimes g_1, f_0 \\otimes g_1 + f_1 \\otimes g_0) \\\\ &amp; = tf(f_0 \\otimes g_0 + f_1 \\otimes g_1 - f_0 \\otimes g_1 - f_1 \\otimes g_0, f_0 \\otimes g_0 + f_1 \\otimes g_1 + f_0 \\otimes g_1 + f_1 \\otimes g_0) \\\\ &amp; = (tf((f_0 - f_1) \\otimes (g_0 - g_1)), tf((f_0 + f_1) \\otimes (g_0 + g_1))) \\\\ &amp; = (tf(f_0 - f_1) \\times tf(g_0 - g_1), tf(f_0 + f_1) \\times tf(g_0 + g_1)) \\\\ &amp; = (tf(f_0 - f_1), tf(f_0 + f_1)) \\times (tf(g_0 - g_1) \\times tf(g_0 + g_1)) \\\\ &amp; = tf(f) \\times tf(g) \\end{aligned} tf(f⊗g)​=tf((f0​,f1​)⊗(g0​,g1​))=tf(f0​⊗g0​+f1​⊗g1​,f0​⊗g1​+f1​⊗g0​)(由对称差卷积的定义得)=tf(f0​⊗g0​+f1​⊗g1​,f0​⊗g1​+f1​⊗g0​)=tf(f0​⊗g0​+f1​⊗g1​−f0​⊗g1​−f1​⊗g0​,f0​⊗g0​+f1​⊗g1​+f0​⊗g1​+f1​⊗g0​)=(tf((f0​−f1​)⊗(g0​−g1​)),tf((f0​+f1​)⊗(g0​+g1​)))=(tf(f0​−f1​)×tf(g0​−g1​),tf(f0​+f1​)×tf(g0​+g1​))=(tf(f0​−f1​),tf(f0​+f1​))×(tf(g0​−g1​)×tf(g0​+g1​))=tf(f)×tf(g)​ 命题得证。 同理，可以定义逆变换 utf(f⊗g)=(utf(f0+f12),utf(f0−f12))utf(f \\otimes g) = (utf(\\frac {f_0+f_1}{2}), utf(\\frac {f_0-f_1}{2})) utf(f⊗g)=(utf(2f0​+f1​​),utf(2f0​−f1​​)) 只要证明这个逆变换满足 utf((tf(f0+f1),tf(f0−f1)))=futf((tf(f_0+f_1), tf(f_0 - f_1))) = f utf((tf(f0​+f1​),tf(f0​−f1​)))=f 即可。 事实上，tf(f+g)=tf(f)+tf(g)tf(f + g) = tf(f) + tf(g)tf(f+g)=tf(f)+tf(g)也是恒成立的。 因此可以改写式子： tf(f)=(tf(f0−f1),tf(f0+f1))=(tf(f0)−tf(f1),tf(f0)+tf(f1))tf(f) = (tf(f_0 - f_1), tf(f_0 + f_1)) = (tf(f_0) - tf(f_1), tf(f_0) + tf(f_1)) tf(f)=(tf(f0​−f1​),tf(f0​+f1​))=(tf(f0​)−tf(f1​),tf(f0​)+tf(f1​)) 组合计数 反演 反演的本质。 已知：f(n)=∑i=0nan,ig(i)​f(n) = \\sum_{i = 0} ^ n a_{n, i} g(i)​f(n)=∑i=0n​an,i​g(i)​ 即： \\begin{pmatrix} f(0)\\\\ f(1)\\\\ f(2)\\\\ \\vdots\\\\ f(n) \\end{pmatrix}= \\begin{pmatrix} a_{0,0}&amp;0&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{1,0}&amp;a_{1,1}&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{2,0}&amp;a_{2,1}&amp;a_{2,2}&amp;0&amp;\\cdots&amp;0\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ a_{n,0}&amp;a_{n,1}&amp;a_{n,2}&amp;a_{n,3}&amp;\\cdots&amp;a_{n,n}\\\\ \\end{pmatrix} \\begin{pmatrix} g(0)\\\\\\ g(1)\\\\\\ g(2)\\\\\\ \\vdots\\\\\\ g(n) \\end{pmatrix} 反演即是求：g(n)=∑i=0nbn,if(i)​g(n) = \\sum_{i = 0} ^ n b_{n, i}f(i)​g(n)=∑i=0n​bn,i​f(i)​ 考虑f(n)=∑i=0nan,i∑j=0ibi,jf(j)​f(n) = \\sum_{i = 0} ^ n a_{n, i} \\sum_{j = 0} ^ i b_{i, j} f(j)​f(n)=∑i=0n​an,i​∑j=0i​bi,j​f(j)​，也就是下面这个矩阵中所有元素之和： (an,0b0,0f(0)000⋯0an,1b1,0f(0)an,1b1,1f(1)00⋯0an,2b2,0f(0)an,2b2,1f(1)an,2b2,2f(2)0⋯0⋮⋮⋮⋮⋱⋮an,nbn,0f(0)an,nbn,1f(1)an,nbn,2f(2)an,nbn,3f(3)⋯an,nbn,nf(n))\\begin{pmatrix} a_{n,0}b_{0,0}f(0)&amp;0&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{n,1}b_{1,0}f(0)&amp;a_{n,1}b_{1,1}f(1)&amp;0&amp;0&amp;\\cdots&amp;0\\\\ a_{n,2}b_{2,0}f(0)&amp;a_{n,2}b_{2,1}f(1)&amp;a_{n,2}b_{2,2}f(2)&amp;0&amp;\\cdots&amp;0\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ a_{n,n}b_{n,0}f(0)&amp;a_{n,n}b_{n,1}f(1)&amp;a_{n,n}b_{n,2}f(2)&amp;a_{n,n}b_{n,3}f(3)&amp;\\cdots&amp;a_{n,n}b_{n,n}f(n)\\\\ \\end{pmatrix} ⎝⎜⎜⎜⎜⎜⎛​an,0​b0,0​f(0)an,1​b1,0​f(0)an,2​b2,0​f(0)⋮an,n​bn,0​f(0)​0an,1​b1,1​f(1)an,2​b2,1​f(1)⋮an,n​bn,1​f(1)​00an,2​b2,2​f(2)⋮an,n​bn,2​f(2)​000⋮an,n​bn,3​f(3)​⋯⋯⋯⋱⋯​000⋮an,n​bn,n​f(n)​⎠⎟⎟⎟⎟⎟⎞​ 又因为f(n)=∑j=0nf(j)∑i=jnan,ibi,jf(n) = \\sum_{j = 0} ^ n f(j) \\sum_{i = j} ^ n a_{n, i}b_{i, j}f(n)=∑j=0n​f(j)∑i=jn​an,i​bi,j​，所以如果能构造出b​b​b​矩阵满足 ∑i=jnan,ibi,j={1,j=n0,j≠n\\sum_{i = j} ^ n a_{n, i}b_{i, j} = \\begin{cases} 1, &amp; j = n \\\\ 0, &amp; j \\neq n \\\\ \\end{cases} i=j∑n​an,i​bi,j​={1,0,​j=nj​=n​ 即 ∑i=jnan,ibi,j=[j==n]\\sum_{i = j} ^ n a_{n, i} b_{i, j} = [j == n] i=j∑n​an,i​bi,j​=[j==n] 就可以愉快地反演啦！因为这个式子知道了aaa矩阵就可以逐行递推出bbb矩阵，递推顺序见下（以4×4矩阵为例）： 40007300962010851\\begin{matrix} 4 &amp; 0 &amp; 0 &amp; 0 \\\\ 7 &amp; 3 &amp; 0 &amp; 0 \\\\ 9 &amp; 6 &amp; 2 &amp; 0 \\\\ 10 &amp; 8 &amp; 5 &amp; 1 \\\\ \\end{matrix} 47910​0368​0025​0001​ 其中000的位置代表值为000，也就是我们不需要计算。 数据结构 动态树(link-cut-tree) 沿用树链剖分思想，只是构建了辅助树。辅助树由多棵splay组成，每棵splay通过实边维护重链，中序遍历的话正好是链头到链尾的节点；splay之间通过虚边维护轻边，虚边上的父节点正是轻边上的父节点，但轻边上的子节点是以虚边上的子节点为根的splay中中序遍历最小的点。 辅助函数： Nonroot(x) 作用：判断xxx是否为非splay根的节点。 实现： 1234&gt; bool Nonroot (int x) &#123;&gt; return lc[fa[x]] == x || rc[fa[x]] == x;&gt; &#125;&gt; Side(x) 作用：判断x​x​x​是其父节点的左(0)/右(1)子树。 实现： 1234&gt; bool Side (int x) &#123;&gt; return rc[fa[x]] == x;&gt; &#125;&gt; Pushup(x) 作用：上传x​x​x​子节点信息。 实现： 1234&gt; void Pushup (int x) &#123;&gt; ...&gt; &#125;&gt; Pushrev(x) 作用：下传xxx的rev标记。 实现： 1234&gt; void Pushrev (int x) &#123;&gt; swap(lc[x], rc[x]), r[x] ^= 1;&gt; &#125;&gt; Pushdown(x) 作用：下传xxx的懒标记。 实现： 12345678&gt; void Pushdown (int x) &#123;&gt; if (rev[x]) &#123;&gt; if (lc[x]) Pushrev(lc[x]);&gt; if (rc[x]) Pushrev(rc[x]);&gt; rev[x] = 0;&gt; &#125;&gt; &#125;&gt; 主要操作函数： Rotate(x) 作用：将x​x​x​向根方向旋转一次。 实现： 123456789&gt; void Rotate (int x) &#123;&gt; int y = fa[x], z = fa[y], sx = Side(x), sy = Side(y);&gt; if (Nonroot(y)) c(z, sy) = x;&gt; fa[x] = z;&gt; fa[c(y, sx) = c(x, sx ^ 1)] = y;&gt; fa[c(x, sx ^ 1) = y] = x;&gt; Pushup(y), Pushup(x);&gt; &#125;&gt; Splay(x)​ 作用：将xxx旋转到其所在splay树的根节点。 实现： 12345678910&gt; int st[N];&gt; void Splay (int x) &#123;&gt; st[st[0] = 1] = x;&gt; for (int y = x; Nonroot(y); y = fa[y]) st[++st[0]] = fa[y];&gt; for ( ; st[0]; --st[0]) Pushdown(st[st[0]]);&gt; for (int y = fa[x]; Nonroot(x); Rotate(x), y = fa[x])&gt; if (Nonroot(y)) Rotate(Side(x) ^ Side(y) ? x : y);&gt; Pushup(x);&gt; &#125;&gt; Access(x) 作用：将xxx到原树根的路径上的边都变为重边，且xxx到其原来的重儿子的边变成轻边。 实现： 12345&gt; void Access (int x) &#123;&gt; for (int y = 0; x; y = x, x = fa[x])&gt; Splay(x), rc[x] = y, Pushup(x);&gt; &#125;&gt; Makeroot(x)​ 作用：将原树的根换成点xxx。 实现： 1234&gt; void Makeroot (int x) &#123;&gt; Access(x), Splay(x), Pushrev(x);&gt; &#125;&gt; Findroot(x)​ 作用：找到xxx所在原树的树根（主要用来判断连通性）。 实现： 1234567&gt; void Findroot (int x) &#123;&gt; Access(x), Splay(x);&gt; for ( ; lc[x]; x = lc[x]) Pushdown(x);&gt; Splay(x);&gt; return x;&gt; &#125;&gt; Split(x, y)​ 作用：将路径x−yx - yx−y拉出，使x,yx, yx,y在一棵splay中（直接查询yyy就可以知道该路径的有关信息）。 实现： 1234&gt; void Split (int x, int y) &#123;&gt; Makeroot(x), Access(y), Splay(y);&gt; &#125;&gt; Link(x, y)​ 作用：连一条x−yx - yx−y的边（如果本来就在一棵树中会return 0）。 实现： 1234&gt; void Link (int x, int y) &#123;&gt; Makeroot(x), fa[x] = y;&gt; &#125;&gt; Cut(x, y) 作用：将边x−yx - yx−y断开。 实现： 12345&gt; void Cut (int x, int y) &#123;&gt; Makeroot(x), Access(y), Splay(y);&gt; lc[y] = fa[x] = 0, Pushup(y);&gt; &#125;&gt; 其他 动态dp 在树（或动态树）上做一类dp，支持单点修改，单点查询。 如果没有修改，可以写出一般的转移方程；但一旦有修改就做不了。 考虑对树进行树链剖分。 对于一个节点有轻重儿子，可以写出关于轻重儿子的转移方程（一般轻儿子的信息可以叠加，可以维护和来处理） 然后对发现是一个类似矩阵乘法的转移。 这里可能要定义新运算⊗​\\otimes​⊗​和⊕​\\oplus​⊕​。 比如树上最大带权独立集， 设fx​f_x​fx​​为表示点x的最大权独立集，gx​g_x​gx​​表示点x不选，其子树的最大权独立集。再设h(x)​h(x)​h(x)​表示点x的重儿子，lfx​lf_x​lfx​​表示x所有轻儿子的f​f​f​ 值的和，lgx​lg_x​lgx​​类似。 则我们可以写出转移： fx=max{gx,lgx+gh(x)+vx}gx=lfx+fh(x)\\begin{aligned} &amp; f_x = max\\{g_x , lg_x + g_{h(x)} + v_x \\} \\\\ &amp; g_x = lf_x + f_{h(x)} \\end{aligned} ​fx​=max{gx​,lgx​+gh(x)​+vx​}gx​=lfx​+fh(x)​​ 然后令x⊗y=x+y​x \\otimes y = x + y​x⊗y=x+y​，x⊕y=max{x,y}​x \\oplus y = max\\{x, y\\}​x⊕y=max{x,y}​，其中x,y​x, y​x,y​是普通的数。我们发现新的运算是结合的且封闭的，那么就可以做矩阵乘法了。并且矩阵乘法中的乘变成了⊗​\\otimes​⊗​，加变成了⊕​\\oplus​⊕​。 则转移变成： [lfxlgx⊗vxlfx−∞][fh(x)gh(x)]=[(lfx⊗fh(x))⊕(lgx⊗vx⊗gh(x))lfx⊗fh(x)]\\left[ \\begin{matrix} lf_x &amp; lg_x \\otimes v_x \\\\ lf_x &amp; -\\infin \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} f_{h(x)} \\\\ g_{h(x)} \\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} (lf_x \\otimes f_{h(x)}) \\oplus (lg_x \\otimes v_x \\otimes g_{h(x)}) \\\\ lf_x \\otimes f_{h(x)} \\\\ \\end{matrix} \\right] [lfx​lfx​​lgx​⊗vx​−∞​][fh(x)​gh(x)​​]=[(lfx​⊗fh(x)​)⊕(lgx​⊗vx​⊗gh(x)​)lfx​⊗fh(x)​​] 其中用到了运算规律： x⊗0=0⊗x=xx⊕−∞=−∞⊕x=x\\begin{aligned} &amp; x \\otimes 0 = 0 \\otimes x = x \\\\ &amp; x \\oplus -\\infin = -\\infin \\oplus x = x \\end{aligned} ​x⊗0=0⊗x=xx⊕−∞=−∞⊕x=x​ 可以看出在这里000是乘法单位元，−∞-\\infin−∞是加法单位元。 然后可以对于每一条重链维护这条重链上点的转移矩阵的乘积。 轻边会在树剖做第二次dfs的时候直接暴力合并上来。就是说，第二次dfs的时候要处理出每个点的转移矩阵，且这个转移矩阵不能把该点的重儿子的贡献算上。但是注意，一个节点的轻儿子的重儿子这种贡献还是会要加入这个节点的转移矩阵的。 单点修改的时候，把向上涉及到的重链都修改掉，遇到轻边就暴力改轻边连上去的节点。 然后查询某一点的dp值即把这个点到这个点所在重链的最深的点的转移矩阵用线段树乘起来即可。注意乘的顺序。 对于本题，复杂度就是O(23nlog⁡n)​O(2 ^ 3 n \\log n)​O(23nlogn)​。可以看出，动态dp需要dp数组维护的种类比较少。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://WHchuan123.github.io/tags/笔记/"},{"name":"算法","slug":"算法","permalink":"http://WHchuan123.github.io/tags/算法/"}]},{"title":"定理汇总","date":"2019-03-17T05:09:54.818Z","path":"2019/03/17/定理汇总/","text":"数学 线性代数 子空间、列空间、零空间、秩 记空间SSS的维度为dim⁡\\dimdim，对于一个n行m列秩为r的矩阵An行m列秩为r的矩阵An行m列秩为r的矩阵A，有定理： dim⁡ C(A)=r\\dim \\ C(A) = rdim C(A)=r（列空间） dim⁡ N(A)=m−r\\dim \\ N(A) = m-rdim N(A)=m−r（零空间） dim⁡ C(AT)=r\\dim \\ C(A^T) = rdim C(AT)=r（A的转置的列空间） dim⁡ N(A)=n−r​\\dim \\ N(A) = n-r​dim N(A)=n−r​（A的转置零空间） 初等应用 解线性方程组Ax=b​Ax=b​Ax=b​。 判断无解或是有解找出解很好办。万一要在无解的情况下找出最优近似解呢？ 这要涉及到拟合直线的问题与投影矩阵。 挂个链接 投影、正交、正交矩阵，Gram-Schmidt正交化 正交：空间S​S​S​和T​T​T​正交简单说就是∀a⃗∈S,b⃗∈T,a⃗⋅b⃗=0​\\forall \\vec a \\in S, \\vec b \\in T, \\vec a \\cdot \\vec b = 0​∀a∈S,b∈T,a⋅b=0​。 正交矩阵：满足PT=P−1​P^T = P^{-1}​PT=P−1​的矩阵。 性质：任一两行行向量或任意两列列向量都正交。 优点：可以简化投影矩阵的一些公式等等。 eg. 旋转矩阵就是一个正交矩阵： [cosθ−sinθsinθcosθ]\\begin{bmatrix} cos\\theta &amp; -sin\\theta \\\\ sin\\theta &amp; cos\\theta \\end{bmatrix} [cosθsinθ​−sinθcosθ​] Gram-Schmidt正交化： 将多个线性无关的向量变成一组正交向量（基）。 思想还是用到做投影的方法。 传送门 行列式 定义：记作det A​det \\ A​det A​或∣A∣​|A|​∣A∣​。 定义式：det A=∑σ∈Snsgn(σ)∏i=1nAσ(i),i​det \\ A = \\sum_{\\sigma \\in S_n} sgn(\\sigma) \\prod_{i=1}^n A_{\\sigma(i),i}​det A=∑σ∈Sn​​sgn(σ)∏i=1n​Aσ(i),i​​ 行列式的性质有很多，最妙的是，任取其中3条当作初始公理，都能推得剩下所有的结论。 下面给出常用的三条公理： ∣detI∣=1​|det I| = 1​∣detI∣=1​； 交换两个行向量使得行列式符号取反； 行列式的对于代数运算的线性性。 从这三条里面还可以有另外7个推论，具体可以看这篇博客： biu 行列式的计算方法： 一般化情况下，可以通过高斯消元，定义式，或代数余子式来计算。 代数余子式 余子式定义：Ai,j​A_{i,j}​Ai,j​​表式将矩阵A​A​A​的第i​i​i​行第j​j​j​列差掉以后剩下的部分求行列式的值。 代数余子式定义：∀i,j​\\forall i, j​∀i,j​，(i,j)​(i,j)​(i,j)​ 这个位置上的代数余子式就是该位置上的余子式乘以(−1)i+j​(-1)^{i+j}​(−1)i+j​。 定理：∀i,det A=∑j=1nAi,j∗ai,j​\\forall i, det \\ A = \\sum_{j = 1}^n A_{i,j}*a_{i,j}​∀i,det A=∑j=1n​Ai,j​∗ai,j​​，其中ai,j​a_{i,j}​ai,j​​表示该位置上的代数余子式。 这个式子叫做按行i​i​i​展开式，同样可以按列展开。 伴随矩阵 定义矩阵AAA的伴随矩阵为A∗A^*A∗，其位置(i,j)(i,j)(i,j)上的元素为矩阵AAA中位置(j,i)(j,i)(j,i)上的代数余子式。 经典定理： AA∗=∣A∣IAA^{*} = |A|IAA∗=∣A∣I 应用 特征值和特征向量 在一个线性变换里，有些向量不改变其方向，只是伸缩了常数倍。这种向量叫做特征向量。其伸缩的倍数叫做特征值。 而对于这个线性变换，从另一个角度看，相当于绕着特征向量旋转。 下面给出一些定义式： Av⃗=λv⃗A\\vec v=\\lambda\\vec v Av=λv 这是特征向量的定义，其中A​A​A​是给定的一个普通的矩阵，而λ​\\lambda​λ​就是这个向量的特征值。 我们讲这个式子变形： Av⃗=(λI)v⃗(A−λI)v⃗=0A\\vec v=(\\lambda I)\\vec v \\\\ (A-\\lambda I)\\vec v=0 Av=(λI)v(A−λI)v=0 形式上看，我们找的特征值就是使得(A−λI)​(A-\\lambda I)​(A−λI)​成为一个降维变换，而其中的特征向量就是在这个变换中变成0向量的向量。 相似矩阵 用特征向量作为基，所得的矩阵成为相似矩阵，又称为基变换矩阵。 实际上，基变换矩阵处理的就是一个改变视角的问题。 比如我需要在这个某个坐标系AAA下知道逆时针旋转θ\\thetaθ弧度的变换矩阵，设在元坐标系下旋转矩阵TTT为： [cosθ−sinθsinθcosθ] \\begin{bmatrix} cos\\theta &amp; -sin\\theta \\\\ sin\\theta &amp; cos\\theta \\end{bmatrix} [cosθsinθ​−sinθcosθ​] 则新的旋转矩阵就是$$ T’= A^{-1}TA ​$$。 这个形式值得注意。 对角阵和对角化 对角阵是相似矩阵中的一种。如果矩阵A​A​A​可以“对角化”，就说有对角阵。 n​n​n​阶方阵A​A​A​可以对角化的充分必要条件是：A​A​A​有n​n​n​个线性无关的特征向量。 对角阵的几何含义就是其所有的基向量都是特征向量。 这种矩阵有什么性质？它自乘n​n​n​次的矩阵很好计算！ 如果A​A​A​可以对角化，即存在可逆矩阵P​P​P​和对角阵D​D​D​ 使得 D=P−1APD=P^{-1}AP D=P−1AP 则 An=PDnP−1A^{n}=PD^{n}P^{-1} An=PDnP−1 具体这个PPP矩阵的求法可以先求出所有特征向量，然后排成一排就是这个PPP了。 矩阵树定理(Matrix-Tree)： 对于一个无向图G​G​G​，它的生成树个数等于其基尔霍夫(Kirchhoff)矩阵任何一个n−1​n-1​n−1​阶主子式的行列式的绝对值。 n−1n-1n−1阶主子式就是对于一个任意的一个rrr，将矩阵的第rrr行和第rrr列同时删去得到的新矩阵。 其中，基尔霍夫矩阵K​K​K​=度数矩阵D​D​D​-邻接矩阵A​A​A​。 推广：统计所有生成树边权乘积的和 由于矩阵树定理是可以用于有重边的图的，所以一条边(x,y,z)(x, y, z)(x,y,z)可以看做(x,y)(x, y)(x,y)间增加了zzz条边。还是套用矩阵树即可。 柯西-比内公式(Binet-Cauchy)： 对于一个m×n​m \\times n​m×n​的矩阵A​A​A​和一个n×m​n \\times m​n×m​的矩阵B​B​B​，相乘可以得到m×m​m \\times m​m×m​的矩阵C​C​C​。 记[n]​[n]​[n]​为集合{1,2,...,n}​\\{1, 2, ..., n\\}​{1,2,...,n}​，([n]m)​\\binom {[n]}{m}​(m[n]​)​为[n]​[n]​[n]​中无序取出m​m​m​个元素所得的集合族（其大小恰为(nm)​\\binom {n}{m}​(mn​)​）。 则 det⁡C=∑∣S∣∈([n]m)det⁡A[m],S⋅det⁡BS,[m]\\det C = \\sum_{|S| \\in \\binom {[n]}{m}} \\det A_{[m], S} \\cdot \\det B_{S, [m]} detC=∣S∣∈(m[n]​)∑​detA[m],S​⋅detBS,[m]​ 推论： 若m&gt;n​m &gt; n​m&gt;n​，则det⁡C=0​\\det C= 0​detC=0​； 若m=n​m = n​m=n​，则det⁡C=det⁡A⋅det⁡B​\\det C = \\det A \\cdot \\det B​detC=detA⋅detB​； 若m&lt;nm &lt; nm&lt;n，则只能通过上式计算。 当nnn和mmm差不大时比较有用。 注意：这个公式对矩阵元素取值于任何交换环都成立。 拟阵中的最大最小定理： 对于两个定义在同一个全集U​U​U​上的拟阵M1=(U,I1),M2=(U,I2)​M_1 = (U, I_1), M_2 = (U, I_2)​M1​=(U,I1​),M2​=(U,I2​)​，有 max⁡I∈I1∩I2∣I∣=min⁡S∈Ur1(S)+r2(U∖S)\\max_{I \\in I_1 \\cap I_2} |I| = \\min_{S \\in U} r_1(S) + r2(U \\setminus S) I∈I1​∩I2​max​∣I∣=S∈Umin​r1​(S)+r2(U∖S) 证明是不会的，会了也会忘，只知道这个可以用来证明拟阵求交的正确性。 高代 卷积定理： 对于任意变换T​T​T​和任意集合A,B​A, B​A,B​，如果有 T(A)⋅T(B)=T(A∗B)T(A) \\cdot T(B) = T(A * B) T(A)⋅T(B)=T(A∗B) 则称变换TTT对于卷积∗*∗满足卷积定理。 组合计数 容斥原理： ∣⋃i=1nAi∣=∑T⊆S,∣S∣&gt;0(−1)∣T∣−1∣⋂j∈TAj∣(S={1,2,..n})|\\bigcup_{i = 1} ^ n A_i| = \\sum_{T \\subseteq S, |S| &gt; 0} (-1) ^ {|T| - 1} |\\bigcap_{j \\in T} A_j| \\quad (S = \\{1, 2, ..n\\}) ∣i=1⋃n​Ai​∣=T⊆S,∣S∣&gt;0∑​(−1)∣T∣−1∣j∈T⋂​Aj​∣(S={1,2,..n}) 另一种形式： ∣⋂i=1nAi‾∣=∑T⊆S(−1)∣T∣−1∣⋂j∈TAj∣(S={1,2,..n})|\\bigcap_{i = 1} ^ n \\overline {A_i}| = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1} |\\bigcap_{j \\in T} A_j| \\quad (S = \\{1, 2, ..n\\}) ∣i=1⋂n​Ai​​∣=T⊆S∑​(−1)∣T∣−1∣j∈T⋂​Aj​∣(S={1,2,..n}) 其中，0个集合的交是全集U​U​U​。 min-max容斥： 给定集合SSS，设max⁡(S)\\max(S)max(S)为SSS中元素最大值，min⁡(S)\\min(S)min(S)为SSS中的最小值，则有： max⁡(S)=∑T⊆S(−1)∣T∣−1min⁡(T)\\max(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}\\min(T) max(S)=T⊆S∑​(−1)∣T∣−1min(T) 推广： kthmax⁡(S)=∑T⊆S(−1)∣T∣−k(∣T∣−1k−1)min(T)kth\\max(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - k} \\binom {|T| - 1}{k - 1}min(T) kthmax(S)=T⊆S∑​(−1)∣T∣−k(k−1∣T∣−1​)min(T) 推论： lcm(S)=∑T⊆S(−1)∣T∣−1gcd(T)lcm(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}gcd(T) lcm(S)=T⊆S∑​(−1)∣T∣−1gcd(T) 反演： 莫比乌斯反演： f(n)=∑d∣ng(d)⟺g(n)=∑d∣nμ(d)f(nd)f(n)=∑n∣dg(d)⟺g(n)=∑n∣dμ(dn)f(d)f(n) = \\sum_{d | n} g(d) \\Longleftrightarrow g(n) = \\sum_{d | n} \\mu(d) f(\\frac {n}{d}) \\\\ f(n) = \\sum_{n | d} g(d) \\Longleftrightarrow g(n) = \\sum_{n | d} \\mu(\\frac {d}{n}) f(d) \\\\ f(n)=d∣n∑​g(d)⟺g(n)=d∣n∑​μ(d)f(dn​)f(n)=n∣d∑​g(d)⟺g(n)=n∣d∑​μ(nd​)f(d) 关键： [n==1]⇔∑d∣nμ(d)[n == 1] \\Leftrightarrow \\sum_{d | n} \\mu(d) [n==1]⇔d∣n∑​μ(d) 二项式反演： f(n)=∑i=0n(ni)g(i)⟺g(n)=∑i=0n(ni)(−1)n−if(i)f(n) = \\sum_{i = 0} ^ n \\binom {n}{i} g(i) \\Longleftrightarrow g(n) = \\sum_{i = 0} ^ n \\binom {n}{i} (-1) ^ {n - i} f(i) f(n)=i=0∑n​(in​)g(i)⟺g(n)=i=0∑n​(in​)(−1)n−if(i) 关键： [n==0]⇔(1−1)n⇔∑i=0n(−1)i[n == 0] \\Leftrightarrow (1 - 1) ^ n \\Leftrightarrow \\sum_{i = 0} ^ n (-1) ^ i [n==0]⇔(1−1)n⇔i=0∑n​(−1)i 最值反演： max⁡(S)=∑T⊆S(−1)∣T∣−1min⁡(T)⟺min⁡(S)=∑T⊆S(−1)∣T∣−1max⁡(T)\\max(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}\\min(T) \\Longleftrightarrow \\min(S) = \\sum_{T \\subseteq S} (-1) ^ {|T| - 1}\\max(T) max(S)=T⊆S∑​(−1)∣T∣−1min(T)⟺min(S)=T⊆S∑​(−1)∣T∣−1max(T) 关键： [S==∅]⇔∑T⊆S(−1)∣S∣−∣T∣min(S)=∑T⊆S(−1)∣T∣−∣S∣min(T)[S==T][S == \\emptyset] \\Leftrightarrow \\sum_{T \\subseteq S} (-1) ^ {|S| - |T|} \\\\ min(S) = \\sum_{T \\subseteq S}(-1) ^ {|T| - |S|}min(T)[S == T] [S==∅]⇔T⊆S∑​(−1)∣S∣−∣T∣min(S)=T⊆S∑​(−1)∣T∣−∣S∣min(T)[S==T] 斯特林反演（并不会推）： f(n)=∑i=0ns1(n,i)g(i)⟺g(n)=∑i=0ns2(n,i)(−1)n−if(i)f(n)=∑i=0ns2(n,i)g(i)⟺g(n)=∑i=0ns1(n,i)(−1)n−if(i)f(n) = \\sum_{i = 0} ^ n s_1(n, i)g(i) \\Longleftrightarrow g(n) = \\sum_{i = 0} ^ n s_2(n, i)(-1) ^ {n - i} f(i) \\\\ f(n) = \\sum_{i = 0} ^ n s_2(n, i)g(i) \\Longleftrightarrow g(n) = \\sum_{i = 0} ^ n s_1(n, i)(-1) ^ {n - i} f(i) f(n)=i=0∑n​s1​(n,i)g(i)⟺g(n)=i=0∑n​s2​(n,i)(−1)n−if(i)f(n)=i=0∑n​s2​(n,i)g(i)⟺g(n)=i=0∑n​s1​(n,i)(−1)n−if(i) 关键： ∑i=1ns1(n,k)s2(k,m)(−1)n−k=[m==n]∑i=1ns2(n,k)s1(k,m)(−1)n−k=[m==n]\\sum_{i = 1} ^ n s_1(n, k) s_2(k, m) (-1) ^ {n - k} = [m == n] \\\\ \\sum_{i = 1} ^ n s_2(n, k) s_1(k, m) (-1) ^ {n - k} = [m == n] i=1∑n​s1​(n,k)s2​(k,m)(−1)n−k=[m==n]i=1∑n​s2​(n,k)s1​(k,m)(−1)n−k=[m==n] 单位根反演（FFT里面要用的东西）： f(n)=∑i=0n−1ωnnig(i)⟺g(n)=1n∑i=0n−1ωn−nif(i)f(n) = \\sum_{i = 0} ^ {n - 1} \\omega_n ^ {ni} g(i) \\Longleftrightarrow g(n) = \\frac {1}{n} \\sum_{i = 0} ^ {n - 1} \\omega_n ^ {-ni} f(i) f(n)=i=0∑n−1​ωnni​g(i)⟺g(n)=n1​i=0∑n−1​ωn−ni​f(i) 关键： [k∣n]=1k∑i=0k−1ωkni[k | n] = \\frac {1}{k} \\sum_{i = 0} ^ {k - 1} \\omega_k ^ {ni} [k∣n]=k1​i=0∑k−1​ωkni​ 子集反演： f(S)=∑T⊆Sg(T)⟺g(S)=∑T⊆S(−1)∣S∣−∣T∣f(T)f(S) = \\sum_{T \\subseteq S} g(T) \\Longleftrightarrow g(S) = \\sum_{T \\subseteq S}(-1) ^ {|S| - |T|}f(T) f(S)=T⊆S∑​g(T)⟺g(S)=T⊆S∑​(−1)∣S∣−∣T∣f(T) 关键： [S==∅]⇔∑T⊆S(−1)∣S∣−∣T∣[S == \\emptyset] \\Leftrightarrow \\sum_{T \\subseteq S} (-1) ^ {|S| - |T|} [S==∅]⇔T⊆S∑​(−1)∣S∣−∣T∣ 概率和期望 期望的积分式： E=∫0+∞P(x)dx（连续型）E=∑i=0nP(i)(离散型)E = \\int_0 ^ {+\\infty} P(x)dx（连续型）\\\\ E = \\sum_{i = 0} ^ n P(i) (离散型) E=∫0+∞​P(x)dx（连续型）E=i=0∑n​P(i)(离散型) 某定理： 对于nnn个[0,1][0,1][0,1]之间的随机变量x1,x2,...,xnx_1,x_2,...,x_nx1​,x2​,...,xn​，第kkk小的那个的期望值是kn+1\\frac {k}{n+1}n+1k​。 条件概率： 定理P(A∣B)P(A|B)P(A∣B)为BBB已经发生的基础上，AAA发生的概率。 则有 1.定义得出： P(A∣B)=P(AB)P(B)P(A|B) = \\frac{P(AB)}{P(B)} P(A∣B)=P(B)P(AB)​ 2.类似于容斥原理（AB​AB​AB​即A∩B​A \\cap B​A∩B​）： P(AB)=P(A)+P(B)−P(A∪B)P(AB) = P(A) + P(B) - P(A \\cup B) P(AB)=P(A)+P(B)−P(A∪B) 3.全概率公式（其中∀i=j,Bi∩Bj=∅​\\forall i \\not= j, B_i \\cap B_j = \\emptyset​∀i​=j,Bi​∩Bj​=∅​，且∑P(Bk)=1​\\sum P(B_k) = 1​∑P(Bk​)=1​）： P(A)=∑P(A∣Bk)P(Bk)P(A) = \\sum P(A|B_k)P(B_k) P(A)=∑P(A∣Bk​)P(Bk​) 4.贝叶斯公式： P(A∣B)=P(B∣A)P(A)P(B)P(A|B) = \\frac{P(B|A)P(A)}{P(B)} P(A∣B)=P(B)P(B∣A)P(A)​ 期望相关： 若两个变量X,Y​X, Y​X,Y​独立，则E(XY)=E(X)E(Y)​E(XY) = E(X)E(Y)​E(XY)=E(X)E(Y)​。 对于任意两个变量X,Y​X, Y​X,Y​，常数a,b​a, b​a,b​，则E(aX+bY)=aE(X)+bE(Y)​E(aX + bY) = aE(X) + bE(Y)​E(aX+bY)=aE(X)+bE(Y)​。 逻辑数学 反演定理： 对于一个逻辑式YYY，若将其中所有的∧\\land∧，∨\\lor∨都对换（指的是变成相对的那个），000，111都对换，变量都取反（如果原来已经取反了那就变回原变量），则新的逻辑式是YYY的非，即Y‾\\overline YY。（注意，不属于单个变量的取反符号不变） 网络流及二分图 霍尔定理(Hall Theorem)： 假设二分图G={X,Y}​G = \\{X, Y\\}​G={X,Y}​存在完美匹配，等价于取任意正整数1≤k≤∣X∣​1 \\leq k \\leq |X|​1≤k≤∣X∣​，均满足我从X​X​X​集合选出k​k​k​个不同的点，那么它们总的连向的Y​Y​Y​集合的不同点个数不小于k​k​k​。 推广： 有二分图G={X,Y}​G = \\{X, Y\\}​G={X,Y}​，若X′⊆X​X&#x27; \\subseteq X​X′⊆X​中的点在Y​Y​Y​中可以被全部匹配，当且仅当对于X′​X&#x27;​X′​的任意子集S​S​S​，满足S​S​S​在Y​Y​Y​中的相邻顶点组成的点集T​T​T​有∣T∣≥∣S∣​|T| \\ge |S|​∣T∣≥∣S∣​。 图特定理(Tutte Theorem)： 在二分图G={X,Y}​G = \\{X, Y\\}​G={X,Y}​中，只要X′⊆X​X&#x27; \\subseteq X​X′⊆X​可以被某个匹配盖住,Y′⊆Y​Y&#x27; \\subseteq Y​Y′⊆Y​也可以被某个匹配盖住（不需要是同一个匹配），那么X′∪Y′​X&#x27; \\cup Y&#x27;​X′∪Y′​也可以被某个匹配盖住。 博弈 SG函数： SGX=MEX({SGY∣(X,Y)∈E})SG_X = MEX(\\{SG_Y | (X, Y) \\in E\\}) SGX​=MEX({SGY​∣(X,Y)∈E}) 其中，E​E​E​是转移集合，(X,Y)​(X, Y)​(X,Y)​是一个转移。 SG定理： 若SGXSG_XSGX​为0，则XXX是一个必败态。（要满足整个游戏不存在平局态） 证明用归纳。 exSG定理： 设一个游戏间的运算+++，X+YX+YX+Y表示将两个游戏复合，即这两个游戏不互相影响，但在同一个游戏X+YX+YX+Y中。 设游戏X=X1+X2+…+Xn​X = X_1 + X_2 + \\ldots + X_n​X=X1​+X2​+…+Xn​​，则SGX=SGX1⊕SGX2⊕…⊕SGXn​SG_X = SG_{X_1} \\oplus SG_{X_2} \\oplus \\ldots \\oplus SG_{X_n}​SGX​=SGX1​​⊕SGX2​​⊕…⊕SGXn​​​。 其证明就是要证明这类游戏的SG函数的两个性质： 1.∀a∈N,a&lt;b,∃X′∈FX,SGX′=a​\\forall a \\in N, a &lt; b, \\exists X&#x27; \\in F_X, SG_{X&#x27;} = a ​∀a∈N,a&lt;b,∃X′∈FX​,SGX′​=a​； 2.∀X′∈FX,SGX′≠b​\\forall X&#x27; \\in F_X, SG_{X&#x27;} \\neq b​∀X′∈FX​,SGX′​​=b​。 其中X′​X&#x27;​X′​是游戏X​X​X​的一个转移，FX​F_X​FX​​是游戏X​X​X​的转移集合。 证明一个归纳，一个反证。 纳什均衡： 一个重要的约束：双方的选择都是独立的，即不受对方选择的影响。 进行博弈的双方因为站在“对抗”的角度而非“合作”的角度上进行游戏，双方都想最大化子自己的收益/最小化对方的收益，且由于双方选择不受对方影响，在双方都不知道对方决策的情况下，一定会调整自己选择的概率使得自己的期望收益在对手采取不同策略的情况下达到平衡。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://WHchuan123.github.io/tags/笔记/"},{"name":"定理","slug":"定理","permalink":"http://WHchuan123.github.io/tags/定理/"}]},{"title":"共勉","date":"2019-03-17T00:40:55.619Z","path":"2019/03/17/共勉/","text":"曾经在某吧里面看到了一个远古帖子，许多湖北省的oier在对省队选拔中出现的偏差非常不满。不管孰错孰对，vfk在那里说的一段话令我惊叹。惊叹后是沉思。 节选如下： 我认为信息学竞赛考察的是信息学的思想，为了考察思想就得用一些手段。举一个简单的例子：XXXXXXXXXXXXXXXXXX，求最小值。假设这题方法是dp。这是纯信息题，认同吧。但是这样有缺点：既然是最小值嘛，有人可以绕开dp，用随机化之类的东西混分。 于是就有了：XXXXXXXXXXXXXXXXXX，求方案数。XXXXXXXXXXXXXXXXXX，求期望。我们假设还是能用类似的dp做。于是LZ可能就不服了：不公平！数学题！min有一个性质：min(a, b, c) = min(min(a, b), min(b, c))但是加法没有：a + b + c != (a + b) + (b + c)涉及到加法来把所有的解合并起来的东西，都要求你不重不漏，从而更有挑战性。并且避免了随机化骗分。 而且我觉得期望特别厉害，有一些min的性质：min(ka, kb) = kmin(a, b) =&gt; E(kX) = kE(X)min(a + x, a + y, b + x, b + y) = min(a, b) + min(x, y) =&gt; E(X + Y) = E(X) + E(Y)枚举最小答案判定是否有解 =&gt; EX = Pr(X &gt;= 0) + Pr(X &gt;= 1) + Pr(X &gt;= 2) + …所以期望有时候是绝佳的替代品。只要约定俗成假定各位OI选手都知道期望的性质。而事实上，我们高中课本上面还是提了几句的。（虽然讲得比较坑 = =……无力吐槽）如果你专注竞赛那么迟早会在做题中知道期望的性质，如果你专注文化课那么迟早会在数学课上遇见它。 所以我要是出题人，如果我想考dp，我肯定更愿意出方案数和期望，而不是最小值。这是真的是数学题吗？有时候看起来觉得显然是数学题的题目，只是信息学的包装。 再论实际用途。为什么快速排序的期望时间复杂度是O(n log n)而冒泡排序不是？为什么双旋splay的时间复杂度是均摊O(log n)而单旋的不是？为什么并查集的时间复杂度里有个某个阿克曼函数的反函数?为什么线段树的区间查询操作是O(log n)？我估计你没看过证明。不然就不会说出“只有复旦注重数学”。你说数据结构应该算纯信息学。那他的证明中可是货真价实的数学哦。我想问，难道那些发明这些科技的人是用一种“纯粹的算法能力”搞出这些东西，然后再马马虎虎糊弄一下数学证明的吗？显然不是。物理学中有一句令人印象深刻的道理：无论是什么奇谈怪论，只要他能用实验证明是对的，我们就接受他。实验是检验真理的唯一标准。你看，相对论那么颠覆性的东西现在也被人接受了。同样我们也可以说：既然数学给计算机带来了科技，带来了效率上的提升，那好，我们就可以认定数学是信息学思想的一部分。信息学需要数学，但不是纯数学里的数学，也不是物理里的数学。我认为基本上各个领域都需要数学作为支撑，只是用的方面不同。而我认为，信息学竞赛并不是在培养只会写代码的码农。是的，代码能力很重要，但并不只是这些。还是在培养的是能用信息学的思想去创造新的科技的计算机大师。 其实我曾经也一度对OI题中混入数学题感到愤怒。但是静下心来多接触一下我明白了其实并不是在考数学，那个东西就是信息学。 不知道你有没有知道昨天的题解。如果没有建议先去看看吧。仔细想想，于是你会明白没有人在用数学坑OIer。 （说句题外话，现役中小部分比如pyx、以及dzy loves math之流除外。你们都太神了 T_T） 不过我觉得质疑没有数据结构是对的啊。我赞同。但是我想说第三题的部分分里有树状数组。粗略点理解数据结构为何物，第二题的dp中用到了前缀和。（至少我用了……T_T）当然第一试没有出数据结构不代表第二试不会出。如果两试都出现了真数据结构题，那么我觉得是否太频繁了这个值得探讨。其实我觉得有时候数据结构题没出好就变成了裸题，OI赛场变成了打字比赛，AC者众。而且数据结构题的解集多半是多项式级的，而最优化问题、方案数、期望之类多半都是指数级的解集，从而更好出数据卡暴力。综上出题人觉得宁可不出数据结构。 这是我个人对于信息学的见解 = =……求轻喷。我真心希望湖北能出几位计算机大师而不是“为进省队头破血流者”。所以我才会说这么多…… 在这以前，只知道vfk是OI界的master，但是也仅仅是master罢了。 但是看了这段话，我才明白，oier刚开始学OI的目的是不太一样的，但是慢慢地，到了高中以后，竞赛性质凸显，功利化也在所难免。也许我们正在慢慢失去初心…… 初心难守是事实，但是也许就像vfk这样，越是厉害的人，越能懂得OI的意义所在。 对我而言，OI不仅仅是竞赛。OI还是生活。有时我会庆幸我当初没有去其他竞赛。或许我去搞数竞也能混得很好。但是可能又是一个完全不一样的世界了。 换句话说，我对我的现状不说很满足，但是满意了。毕竟我还有梦可追。I&#39;am still young. 以此共勉。活得不必很精彩，但至少要有意义。","tags":[]},{"title":"websites","date":"2019-03-16T13:26:26.995Z","path":"2019/03/16/websites/","text":"这里是一些有用的网站们： latex&amp;markdown相关： latex数学公式汇总 latex语法总结 latex记号一览 数学相关： oeis 某个数的性质 笛卡尔坐标系 数学系列 欧拉计划中文 pe题解 图相关： 建图和树 oi&amp;oj相关： atc数据 集训队作业部分题 图像处理相关： 图像放大 问题相关： stackoverflow","tags":[{"name":"网站","slug":"网站","permalink":"http://WHchuan123.github.io/tags/网站/"}]}]